<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Bobo Huang写字的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Bobo Huang写字的地方">
<meta property="og:url" content="https://huangyibo.github.io/index.html">
<meta property="og:site_name" content="Bobo Huang写字的地方">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bobo Huang写字的地方">
  
    <link rel="alternate" href="/atom.xml" title="Bobo Huang写字的地方" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bobo Huang写字的地方</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://huangyibo.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/22/test/" class="article-date">
  <time datetime="2018-10-22T13:35:00.000Z" itemprop="datePublished">2018-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/22/test/">test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hello World!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/10/22/test/" data-id="cjnkcum64000wdemxw7ustqwx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-System-Primitive-系统原语-的基本原理与实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/22/System-Primitive-系统原语-的基本原理与实践/" class="article-date">
  <time datetime="2018-10-22T12:54:48.000Z" itemprop="datePublished">2018-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/每周技术分享/">每周技术分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/22/System-Primitive-系统原语-的基本原理与实践/">System Primitive(系统原语)的基本原理与实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原语，顾名思义“原”可解释为原子，或原始，即不可再分割的语句或者指令，是内核提供核外调用的过程或者函数。系统原语是指在操作系统中，不可中断，不可分开执行的一条或者一组指令。</p>
<p>根据定义可以判断一些不可中断的操作都可以称之为原语， 例如不同层之间的对话（高层向低层请求某种业务，提供业务的层证实某个动作已经完成）等等，又或者用于进程控制的原语（创建原语，撤销原语，阻塞原语，唤醒原语）</p>
<p>引进原语的主要目的就是实现进程的通信和控制。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>两者都必须在系统态下执行，都是为了完成某个系统管理所需要的功能被高层软件所调用。</p>
<ul>
<li>一类是机器指令级？<br>特点是执行期间不允许中断，在操作系统中是一个不可分割的单位。</li>
<li>另一类是功能型？<br>特点是作为原语的程序段不允许并发执行。</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>必须在管态下执行，常驻内存</li>
<li>不可中断性</li>
</ul>
<h2 id="典型例子P，V原语操作"><a href="#典型例子P，V原语操作" class="headerlink" title="典型例子P，V原语操作"></a>典型例子P，V原语操作</h2><p>在操作系统中，研究进程间的互斥时引入了一个非常重要的概念叫做P，V原语。在后面的实际应用中，不但可以解决进程管理中的互斥问题，而且还可以利用此方法解决进程同步与进程通信的问题。</p>
<p>在解决进程互斥问题时，引入了一个信号量和两个原语操作。假设信号量：S，原语操作时P，V。</p>
<h3 id="P原语操作的动作是："><a href="#P原语操作的动作是：" class="headerlink" title="P原语操作的动作是："></a>P原语操作的动作是：</h3><ol>
<li><p>S减1；</p>
</li>
<li><p>若S减1后仍大于或等于零，则进程继续执行；</p>
</li>
<li><p>若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。</p>
</li>
</ol>
<h3 id="V原语操作的动作是："><a href="#V原语操作的动作是：" class="headerlink" title="V原语操作的动作是："></a>V原语操作的动作是：</h3><ol>
<li><p>S加1；</p>
</li>
<li><p>若相加结果大于零，则进程继续执行：</p>
</li>
<li><p>若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后返回原进程继续执行或转进程调度。</p>
</li>
</ol>
<p><strong>P，V原语操作必须是一一对应，成对出现的。</strong></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>代码执行不希望被打断。</p>
</li>
<li><p>变量（例如内存地址）的测试和修改不被打断。</p>
</li>
</ol>
<blockquote>
<p>问题1：生产者——消费者问题</p>
</blockquote>
<p>该问题是指：若干进程通过有限的共享缓冲区交换数据时的缓冲区资源使用问题。假设“生产者”进程不断向共享缓冲区写入数据（即生产数据），而“消费者”进程不断从共享缓冲区读出数据（即消费数据）；共享缓冲区共有n个；任何时刻只能有一个进程可对共享缓冲区进行操作。所有生产者和消费者之间要协调，以完成对共享缓冲区的操作。</p>
<p>可以把共享缓冲区中的n个缓冲块视作共享资源，生产者写入数据的缓冲块成为消费者可用资源，而消费者读出数据后的缓冲块为生产者的可用资源。为此不妨设三个信号量：Full，Empty，Mutex。其中：Full表示有数据的缓冲块数目，初始为0；Empty为空的缓冲块数目，初始为n；Mutex用于消费者和生产者互斥的访问缓冲区，初始为1。</p>
<ul>
<li>伪代码实现</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Prducer:</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">   begin</span><br><span class="line">   produce(&amp;item);//生产商品</span><br><span class="line">   p(Empty);//空位减1，若Empty已经为0时则等待</span><br><span class="line">   p(Mutex);//互斥信号量减1，Mutex已经为0时则等待</span><br><span class="line">   将商品放入缓冲区；// ***这部分执行是不可被中断的***</span><br><span class="line">   v(Mutex);//释放信号量Mutex+1；</span><br><span class="line">   v(Full);//Full+1；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer:</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  begin</span><br><span class="line">  p(Full);//Full-1</span><br><span class="line">  p(Mutex);//互斥信号量减1，Mutex已经为0时等待</span><br><span class="line">  将商品拿出缓冲区;// ***这部分执行不可被中断***</span><br><span class="line">  v(Mutex);//释放信号量Mutex+1</span><br><span class="line">  v(Empty);//空位+1</span><br><span class="line">  consume(&amp;item);//消费商品</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> buffer_size = <span class="number">10</span>; <span class="comment">// 缓存大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> item_total = <span class="number">100</span>; <span class="comment">//总共要生产 item_total个item</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存结构体, 使用循环队列当做缓存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> buffer[buffer_size];</span><br><span class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">// 当前读位置</span></span><br><span class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">// 当前写位置</span></span><br><span class="line">    mutex mtx; <span class="comment">// 读写互斥</span></span><br><span class="line">    <span class="comment">//条件变量</span></span><br><span class="line">    condition_variable not_full;</span><br><span class="line">    condition_variable not_empty;</span><br><span class="line">&#125;buffer_res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> <span class="title">Buffer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">porduce_item</span><span class="params">(Buffer *b, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(b-&gt;mtx);<span class="comment">//设置互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(((b-&gt;write_position + <span class="number">1</span>) % buffer_size) == b-&gt;read_position) &#123;</span><br><span class="line">        <span class="comment">//当前缓存已经满了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"buffer is full now, producer is wating....."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        (b-&gt;not_full).wait(lock); <span class="comment">// 等待缓存非full</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向缓存中添加item</span></span><br><span class="line">    (b-&gt;buffer)[b-&gt;write_position] = item;</span><br><span class="line">    (b-&gt;write_position)++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若到达最后一个, 写位置置位0</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;write_position == buffer_size)</span><br><span class="line">        b-&gt;write_position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    (b-&gt;not_empty).notify_all();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consume_item</span><span class="params">(Buffer *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    unique_lock &lt;mutex&gt; lock(b-&gt;mtx);</span><br><span class="line">    <span class="keyword">while</span> (b-&gt;write_position == b-&gt;read_position)</span><br><span class="line">    &#123;   <span class="comment">// 当前buffer 为空</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"buffer is empty , consumer is waiting....."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        (b-&gt;not_empty).wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = (b-&gt;buffer)[b-&gt;read_position];</span><br><span class="line">    (b-&gt;read_position)++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;read_position &gt;= buffer_size)</span><br><span class="line">        b-&gt;read_position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    (b-&gt;not_full).notify_all();</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= item_total;i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"prodece the "</span> &lt;&lt; i &lt;&lt; <span class="string">"^th item ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        porduce_item(&amp;buffer_res, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> item = consume_item(&amp;buffer_res);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"consume the "</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (++cnt == item_total)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_buffer</span><span class="params">(Buffer *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b-&gt;write_position = <span class="number">0</span>;</span><br><span class="line">    b-&gt;read_position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_buffer(&amp;buffer_res);</span><br><span class="line">    <span class="function">thread <span class="title">prodece</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">consume</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    prodece.join();</span><br><span class="line">    consume.join();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题2：桌上有一空盘，允许存放一只水果。爸爸可向盘中放苹果，也可向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供吃者取用。</p>
</blockquote>
<p>爸爸、儿子、女儿共用一个盘子，盘中一次只能放一个水果。当盘子为空时，爸爸可将一个水果放入果盘中。若放入果盘中的是桔子，则允许儿子吃，女儿必须等待；若放入果盘中的是苹果，则允许女儿吃，儿子必须等待。本题实际上是生产者-消费者问题的一种变形。这里，生产者放入缓冲区的产品有两类，消费者也有两类，每类消费者只消费其中固定的一类产品。<br>应设置三个信号量S、So、Sa，信号量S表示盘子是否为空，其初值为1；信号量So表示盘中是否有桔子，其初值为0；信号量Sa表示盘中是否有苹果，其初值为0。</p>
<ul>
<li>伪代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int S＝1;</span><br><span class="line">int Sa＝0;</span><br><span class="line">int So＝0;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  cobegin</span><br><span class="line">  father(); //父亲进程</span><br><span class="line">  son(); //儿子进程</span><br><span class="line">  daughter(); //女儿进程</span><br><span class="line">  coend</span><br><span class="line">｝</span><br><span class="line">father()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">  P(S);</span><br><span class="line">  将水果放入盘中;</span><br><span class="line">  if（放入的是桔子）V(So);</span><br><span class="line">  else V(Sa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">son()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line">&#123;</span><br><span class="line">  P(So);</span><br><span class="line">  从盘中取出桔子;</span><br><span class="line">  V(S);</span><br><span class="line">  吃桔子;</span><br><span class="line">｝</span><br><span class="line">&#125;</span><br><span class="line">daughter()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line">&#123;</span><br><span class="line">  P(Sa);</span><br><span class="line">  从盘中取出苹果;</span><br><span class="line">  V(S);</span><br><span class="line"> 吃苹果;</span><br><span class="line">｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解计算机系统》-卡内基·梅隆</p>
<p>《操作系统之PV金典》-王昭礼</p>
<p><a href="https://blog.csdn.net/zscfa/article/details/52969402" target="_blank" rel="noopener">系统原语的原理</a></p>
<p><a href="https://blog.csdn.net/qq_38619183/article/details/80859310" target="_blank" rel="noopener">生产者消费者代码实现</a></p>
<hr>
<p>分享人： 周鑫 金力 黄博博 （复旦大学NiSL）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/10/22/System-Primitive-系统原语-的基本原理与实践/" data-id="cjnkcum5s000udemxr4v1kdzw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Producer-Customer/">Producer-Customer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System-Primitive/">System Primitive</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统原语/">系统原语</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-System-Primitive的基本原理与实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/22/System-Primitive的基本原理与实践/" class="article-date">
  <time datetime="2018-10-22T12:54:48.000Z" itemprop="datePublished">2018-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/每周技术分享/">每周技术分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/22/System-Primitive的基本原理与实践/">System Primitive的基本原理与实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原语，顾名思义“原”可解释为原子，或原始，即不可再分割的语句或者指令，是内核提供核外调用的过程或者函数。系统原语是指在操作系统中，不可中断，不可分开执行的一条或者一组指令。</p>
<p>根据定义可以判断一些不可中断的操作都可以称之为原语， 例如不同层之间的对话（高层向低层请求某种业务，提供业务的层证实某个动作已经完成）等等，又或者用于进程控制的原语（创建原语，撤销原语，阻塞原语，唤醒原语）</p>
<p>引进原语的主要目的就是实现进程的通信和控制。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>两者都必须在系统态下执行，都是为了完成某个系统管理所需要的功能被高层软件所调用。</p>
<ul>
<li>一类是机器指令级？<br>特点是执行期间不允许中断，在操作系统中是一个不可分割的单位。</li>
<li>另一类是功能型？<br>特点是作为原语的程序段不允许并发执行。</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>必须在管态下执行，常驻内存</li>
<li>不可中断性</li>
</ul>
<h2 id="典型例子P，V原语操作"><a href="#典型例子P，V原语操作" class="headerlink" title="典型例子P，V原语操作"></a>典型例子P，V原语操作</h2><p>在操作系统中，研究进程间的互斥时引入了一个非常重要的概念叫做P，V原语。在后面的实际应用中，不但可以解决进程管理中的互斥问题，而且还可以利用此方法解决进程同步与进程通信的问题。</p>
<p>在解决进程互斥问题时，引入了一个信号量和两个原语操作。假设信号量：S，原语操作时P，V。</p>
<h3 id="P原语操作的动作是："><a href="#P原语操作的动作是：" class="headerlink" title="P原语操作的动作是："></a>P原语操作的动作是：</h3><ol>
<li><p>S减1；</p>
</li>
<li><p>若S减1后仍大于或等于零，则进程继续执行；</p>
</li>
<li><p>若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。</p>
</li>
</ol>
<h3 id="V原语操作的动作是："><a href="#V原语操作的动作是：" class="headerlink" title="V原语操作的动作是："></a>V原语操作的动作是：</h3><ol>
<li><p>S加1；</p>
</li>
<li><p>若相加结果大于零，则进程继续执行：</p>
</li>
<li><p>若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后返回原进程继续执行或转进程调度。</p>
</li>
</ol>
<p><strong>P，V原语操作必须是一一对应，成对出现的。</strong></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>代码执行不希望被打断。</p>
</li>
<li><p>变量（例如内存地址）的测试和修改不被打断。</p>
</li>
</ol>
<blockquote>
<p>问题1：生产者——消费者问题</p>
</blockquote>
<p>该问题是指：若干进程通过有限的共享缓冲区交换数据时的缓冲区资源使用问题。假设“生产者”进程不断向共享缓冲区写入数据（即生产数据），而“消费者”进程不断从共享缓冲区读出数据（即消费数据）；共享缓冲区共有n个；任何时刻只能有一个进程可对共享缓冲区进行操作。所有生产者和消费者之间要协调，以完成对共享缓冲区的操作。</p>
<p>可以把共享缓冲区中的n个缓冲块视作共享资源，生产者写入数据的缓冲块成为消费者可用资源，而消费者读出数据后的缓冲块为生产者的可用资源。为此不妨设三个信号量：Full，Empty，Mutex。其中：Full表示有数据的缓冲块数目，初始为0；Empty为空的缓冲块数目，初始为n；Mutex用于消费者和生产者互斥的访问缓冲区，初始为1。</p>
<ul>
<li>伪代码实现</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Prducer:</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">   begin</span><br><span class="line">   produce(&amp;item);//生产商品</span><br><span class="line">   p(Empty);//空位减1，若Empty已经为0时则等待</span><br><span class="line">   p(Mutex);//互斥信号量减1，Mutex已经为0时则等待</span><br><span class="line">   将商品放入缓冲区；// ***这部分执行是不可被中断的***</span><br><span class="line">   v(Mutex);//释放信号量Mutex+1；</span><br><span class="line">   v(Full);//Full+1；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer:</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  begin</span><br><span class="line">  p(Full);//Full-1</span><br><span class="line">  p(Mutex);//互斥信号量减1，Mutex已经为0时等待</span><br><span class="line">  将商品拿出缓冲区;// ***这部分执行不可被中断***</span><br><span class="line">  v(Mutex);//释放信号量Mutex+1</span><br><span class="line">  v(Empty);//空位+1</span><br><span class="line">  consume(&amp;item);//消费商品</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> buffer_size = <span class="number">10</span>; <span class="comment">// 缓存大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> item_total = <span class="number">100</span>; <span class="comment">//总共要生产 item_total个item</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存结构体, 使用循环队列当做缓存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> buffer[buffer_size];</span><br><span class="line">    <span class="keyword">size_t</span> read_position; <span class="comment">// 当前读位置</span></span><br><span class="line">    <span class="keyword">size_t</span> write_position; <span class="comment">// 当前写位置</span></span><br><span class="line">    mutex mtx; <span class="comment">// 读写互斥</span></span><br><span class="line">    <span class="comment">//条件变量</span></span><br><span class="line">    condition_variable not_full;</span><br><span class="line">    condition_variable not_empty;</span><br><span class="line">&#125;buffer_res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Buffer</span> <span class="title">Buffer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">porduce_item</span><span class="params">(Buffer *b, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(b-&gt;mtx);<span class="comment">//设置互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(((b-&gt;write_position + <span class="number">1</span>) % buffer_size) == b-&gt;read_position) &#123;</span><br><span class="line">        <span class="comment">//当前缓存已经满了</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"buffer is full now, producer is wating....."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        (b-&gt;not_full).wait(lock); <span class="comment">// 等待缓存非full</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向缓存中添加item</span></span><br><span class="line">    (b-&gt;buffer)[b-&gt;write_position] = item;</span><br><span class="line">    (b-&gt;write_position)++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若到达最后一个, 写位置置位0</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;write_position == buffer_size)</span><br><span class="line">        b-&gt;write_position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    (b-&gt;not_empty).notify_all();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consume_item</span><span class="params">(Buffer *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    unique_lock &lt;mutex&gt; lock(b-&gt;mtx);</span><br><span class="line">    <span class="keyword">while</span> (b-&gt;write_position == b-&gt;read_position)</span><br><span class="line">    &#123;   <span class="comment">// 当前buffer 为空</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"buffer is empty , consumer is waiting....."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        (b-&gt;not_empty).wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = (b-&gt;buffer)[b-&gt;read_position];</span><br><span class="line">    (b-&gt;read_position)++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;read_position &gt;= buffer_size)</span><br><span class="line">        b-&gt;read_position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    (b-&gt;not_full).notify_all();</span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= item_total;i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"prodece the "</span> &lt;&lt; i &lt;&lt; <span class="string">"^th item ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        porduce_item(&amp;buffer_res, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> item = consume_item(&amp;buffer_res);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"consume the "</span> &lt;&lt; item &lt;&lt; <span class="string">"^th item"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (++cnt == item_total)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_buffer</span><span class="params">(Buffer *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b-&gt;write_position = <span class="number">0</span>;</span><br><span class="line">    b-&gt;read_position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_buffer(&amp;buffer_res);</span><br><span class="line">    <span class="function">thread <span class="title">prodece</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">consume</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    prodece.join();</span><br><span class="line">    consume.join();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题2：桌上有一空盘，允许存放一只水果。爸爸可向盘中放苹果，也可向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供吃者取用。</p>
</blockquote>
<p>爸爸、儿子、女儿共用一个盘子，盘中一次只能放一个水果。当盘子为空时，爸爸可将一个水果放入果盘中。若放入果盘中的是桔子，则允许儿子吃，女儿必须等待；若放入果盘中的是苹果，则允许女儿吃，儿子必须等待。本题实际上是生产者-消费者问题的一种变形。这里，生产者放入缓冲区的产品有两类，消费者也有两类，每类消费者只消费其中固定的一类产品。<br>应设置三个信号量S、So、Sa，信号量S表示盘子是否为空，其初值为1；信号量So表示盘中是否有桔子，其初值为0；信号量Sa表示盘中是否有苹果，其初值为0。</p>
<ul>
<li>伪代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int S＝1;</span><br><span class="line">int Sa＝0;</span><br><span class="line">int So＝0;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  cobegin</span><br><span class="line">  father(); //父亲进程</span><br><span class="line">  son(); //儿子进程</span><br><span class="line">  daughter(); //女儿进程</span><br><span class="line">  coend</span><br><span class="line">｝</span><br><span class="line">father()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">  P(S);</span><br><span class="line">  将水果放入盘中;</span><br><span class="line">  if（放入的是桔子）V(So);</span><br><span class="line">  else V(Sa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">son()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line">&#123;</span><br><span class="line">  P(So);</span><br><span class="line">  从盘中取出桔子;</span><br><span class="line">  V(S);</span><br><span class="line">  吃桔子;</span><br><span class="line">｝</span><br><span class="line">&#125;</span><br><span class="line">daughter()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line">&#123;</span><br><span class="line">  P(Sa);</span><br><span class="line">  从盘中取出苹果;</span><br><span class="line">  V(S);</span><br><span class="line"> 吃苹果;</span><br><span class="line">｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解计算机系统》-卡内基·梅隆</p>
<p>《操作系统之PV金典》-王昭礼</p>
<p><a href="https://blog.csdn.net/zscfa/article/details/52969402" target="_blank" rel="noopener">系统原语的原理</a></p>
<p><a href="https://blog.csdn.net/qq_38619183/article/details/80859310" target="_blank" rel="noopener">生产者消费者代码实现</a></p>
<hr>
<p>分享人： 周鑫 金力 黄博博 （复旦大学NiSL）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/10/22/System-Primitive的基本原理与实践/" data-id="cjnkcum5x000vdemxzoqfais8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Producer-Customer/">Producer-Customer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System-Primitive/">System Primitive</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/系统原语/">系统原语</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bitmap算法-一种基于bit位的数据排序、查重艺术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/" class="article-date">
  <time datetime="2018-10-15T21:23:09.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/每周技术分享/">每周技术分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/">Bitmap算法:一种基于bit位的数据排序、查重艺术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>随着大数据规模的逐渐增长，在单机上的海量数据条目排序、查重、压缩是一项很有挑战性的工作。随之而来的许多硬件加速技术、算法被提出来，并在生产环境中落地实践，Bitmap就是其中一种被普遍应用的大数据排序、查重的算法，该算法巧妙利用了bit位来表示一个数值在一组数据集合中的状态（如某元素是否存在数据集合中），极大地压缩了数据处理（排序、查重）所需要的内存空间。本文将从算法概述、基本原理与实现、算法评估、应用场景与实例四个方面进行阐述。</p>
</blockquote>
<h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>Bitmap（位图算法），是一种基于bit的映射算法，即用一个bit位（或几个bit位）来标记某个元素对应的状态value，而key即是该元素，对应的value即是该元素key的状态（0表示key不存在，1表示key存在），当然也可以根据需要选择多个bit位表示，2个bit标识4种状态，3个bit标识8种状态，n个bit标识2^n种状态。</p>
<p>由此产生了Bitmap位图数据结构。该数据结构描述了一个有限定义域内的稠密集合，其中（1）每一个元素最多出现一次；（2）并且没有其他任何数据与该元素相关联。即使这些条件没有完全满足（例如，存在重复元素或额外的数据），也可以用有限定义域内的键作为一个表项更复杂的表格的索引。</p>
<p>由于采用bit位存储数据，对于海量数据的查重、排序问题，可以大大节省所需内存存储空间，Bitmap算法适用于解决数据集中的每个元素最多出现一次（或n次）并且没有其他任何数据与该元素相关联的问题。</p>
<h3 id="基本原理与实现"><a href="#基本原理与实现" class="headerlink" title="基本原理与实现"></a>基本原理与实现</h3><h4 id="Bitmap算法基本原理"><a href="#Bitmap算法基本原理" class="headerlink" title="Bitmap算法基本原理"></a>Bitmap算法基本原理</h4><p>一个整型数据，比如<code>int a;</code>,在内存中占用32bit，可以用对应的32bit位对应十进制的0-31个数，bitmap算法利用这种思想处理大量数据的排序和查询。</p>
<p>我们举个例子，现在有一个无序有界int数组<code>int[] b = {5,2,11,3}</code>,至少需要占用内存<code>4*4=16</code>个字节，但是如果有10亿个这样的数，大概需要<code>1000000000*4/(1024*1024*1024)=3.72GB</code>左右，如果针对这样大量的数据进行查询排序，内存肯定要溢出崩溃的。</p>
<p>针对上面的问题，使用Bitmap算法就可以轻易解决，一个byte占用8个bit，如果用bit的位置索引表示数组b中的元素值，bit位的取值（0或1）表示该元素在数组中的状态（是否存在），0表示不存在，1表示存在。那么整个过程如下所示：</p>
<ul>
<li>申请一个int型（根据需要也可以申请long型或short型）的内存空间，则有4个Byte，共32bit。然后根据数组下标<code>int[] b = {5,2,11,3}</code>依次遍历5,2,11,3， 把相应的bit位置为1，表示该元素存在。其中，bit区域从低bit位到高bit位，对应的位置索引<code>i</code>即代表要标识的数组<code>int[] b</code>中元素值，bit位为1表示该元素存在数组中，默认为0表示元素不存在：</li>
</ul>
<p><img src="/img/bitmap1.png" alt="步骤1"></p>
<ul>
<li>输入5，将相应的第 6 bit置为1：</li>
</ul>
<p><img src="/img/bitmap2.png" alt="步骤2"></p>
<ul>
<li>输入2，将相应的第 3 bit置为1:</li>
</ul>
<p><img src="/img/bitmap3.png" alt="步骤3"></p>
<ul>
<li>输入11，将相应的第 12 bit置为1:</li>
</ul>
<p><img src="/img/bitmap4.png" alt="步骤4"></p>
<ul>
<li>输入3，将相应的第 4 bit置为1:</li>
</ul>
<p><img src="/img/bitmap5.png" alt="步骤5"></p>
<p>Bitmap算法的基本原理很简单巧妙，关键是十进制和二进制bit之间的转换需要一个映射表，一方面在数据组装初始化时，需要将10进制数据映射到相应的bit位上；另一方面，在遍历一片bit区域时，需要将bit位信息解析为10进制数据及状态（有或无）。</p>
<h4 id="Map映射表"><a href="#Map映射表" class="headerlink" title="Map映射表"></a>Map映射表</h4><p>假设需要排序或者查重的整型数的总数<code>N=10000000=10^7</code>, 那么我们需要申请内存空间的大小为<code>int a[1 + N/32]</code>(或者<code>long long a[1 + N/64]</code>),其中<code>a[0]</code>在内存中占用<code>32bit</code>，依次类推<strong>bitmap</strong>表如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a[0]  --------&gt;  0 ~ 31</span><br><span class="line">a[1]  --------&gt;  32 ~ 63</span><br><span class="line">a[2]  --------&gt;  64 ~ 95</span><br><span class="line">a[3]  --------&gt;  96 ~ 127</span><br><span class="line">......</span><br><span class="line">a[312500]  --------&gt;  (10^7) ~ (10^7 + 31)</span><br><span class="line">......</span><br><span class="line">a[N/32]  --------&gt;   (N/32)*32 ~ ((N/32) * 32 + 31)</span><br></pre></td></tr></table></figure>
<h4 id="Bit位移转换"><a href="#Bit位移转换" class="headerlink" title="Bit位移转换"></a>Bit位移转换</h4><p>为了得到Map映射表，我们需要利用bit位移将10进制数转换位2进制bit位。</p>
<ul>
<li><p>求十进制数 <code>0 - n</code> 对应的在数组 a 中的下标：</p>
<p><code>index_loc = n / 32</code>，32表示int型占用的32bit，<code>index_loc</code>即为n对应的数组下标。例如<code>n = 80</code> , 则<code>index_loc = 80 / 32 = 2</code>, 因此<code>n = 80</code>在<code>a[2]</code>中。</p>
</li>
<li><p>求十进制数 <code>0 - n</code> 对应的bit位:</p>
<p><code>bit_loc = N % 32</code>，例如 <code>n = 80</code>, <code>bit_loc = 80 % 32 = 16</code>。</p>
</li>
<li><p>利用移位运算 <code>0 - 31</code> 使得<code>a[index_loc]</code>对应的32bit位为1.</p>
</li>
</ul>
<h4 id="Bitmap算法实现（C语言）"><a href="#Bitmap算法实现（C语言）" class="headerlink" title="Bitmap算法实现（C语言）"></a>Bitmap算法实现（C语言）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置所在的bit位为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index_loc, bit_loc;</span><br><span class="line"></span><br><span class="line">    index_loc = n &gt;&gt; SHIFT; <span class="comment">// 等价于n / 32</span></span><br><span class="line">    bit_loc = n &amp; MASK;    <span class="comment">// 等价于n % 32 。 h%2^n = h &amp; (2^n -1)</span></span><br><span class="line"></span><br><span class="line">    arr[index_loc] |= <span class="number">1</span> &lt;&lt; bit_loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述set函数等价于</span></span><br><span class="line"><span class="comment">//void set(int i)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   a[i/32] |= (1&lt;&lt;(i%32));</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化arr[index_loc]所有bit位为0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index_loc;</span><br><span class="line">    index_loc = n &gt;&gt; SHIFT;</span><br><span class="line">    arr[index_loc] &amp;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试n所在的bit位是否为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, flag;</span><br><span class="line">    i = <span class="number">1</span> &lt;&lt; (n &amp; MASK);</span><br><span class="line">    flag = arr[n &gt;&gt; SHIFT] &amp; i;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, num, space, *arr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num) != EOF) &#123;</span><br><span class="line">        <span class="comment">// 确定大小&amp;&amp;动态申请数组</span></span><br><span class="line">        space = num / <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line">        arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化bit位为0</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num; i ++)</span><br><span class="line">            clr(i, arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置num的比特位为1</span></span><br><span class="line">        <span class="built_in">set</span>(num, arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        <span class="keyword">if</span> (test(num, arr)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"成功！\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"失败!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下将对上述代码进行解析：</p>
<ul>
<li><p><code>i&gt;&gt;SHIFT</code>(相当于整除运算<code>i/32</code>，保留商)</p>
<p>其中<code>SHIFT = 5</code>，即i右移5bit，<code>2^5=32</code>,相当于<code>i/32</code>，即求出十进制i对应在数组a中的下标<code>index_loc</code>。比如<code>i=20</code>，通过<code>i&gt;&gt;SHIFT=20&gt;&gt;5=0</code> 可求得<strong>i=20的下标为0</strong>；</p>
</li>
<li><p><code>i &amp; MASK</code> (相当于取模运算<code>i%32</code>，保留余数)</p>
<p>其中<code>MASK=0X1F</code>,十六进制转化为十进制为31，二进制为0001 1111，<code>i &amp;（0001 1111）</code>相当于保留i的后5位。</p>
<p>比如<code>i=23</code>，二进制为：<code>0001 0111</code>，那么<br>  <code>0001 0111 &amp; 0001 1111 = 0001 0111</code> 十进制为：23;</p>
<p>比如<code>i=83</code>，二进制为：<code>0000 0000 0101 0011</code>，那么</p>
<pre><code>`0000 0000 0101 0011   &amp;   0000 0000 0001 0000 = 0000 0000 0001 1111` 十进制为：19 .
</code></pre></li>
<li><p><code>1&lt;&lt;(i &amp; MASK)</code></p>
<p>相当于把1左移 <code>(i &amp; MASK)</code>位, 比如<code>(i &amp; MASK)=20</code>，那么<code>i&lt;&lt;20</code>就相当于：</p>
<pre><code>`0000 0000 0000 0000 0000 0000 0000 0001 &gt;&gt;20 =0000 0000 0000 1000 0000 0000 0000 0000 `
</code></pre></li>
</ul>
<p>-</p>
<h3 id="算法评估"><a href="#算法评估" class="headerlink" title="算法评估"></a>算法评估</h3><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>  对于数据规模为<code>n</code>的整型数据集，Bitmap算法的时间复杂度为<code>O(n)</code>, 空间复杂度为<code>O(1)</code>。 其中，存储bit位信息的数组a大小由最大数max决定。即<code>size_of(a) = max_of(b)</code>, 其中b表示原始数据集，a表示经过bitmap算法映射后的基于bit位的数组。</p>
<p>  对于bitmap排序算法（包括bitmap映射和遍历排序两个步骤），其时间和空间复杂度取决于数据集中的最大值<code>MAX</code>。对于数据规模为<code>n</code>的整型数据集，如果采用int型数组表示bitmap信息，即每32bit为一个单元，则其时间复杂度为<code>O(max(n, MAX/32))</code>, 如果在遍历排序阶段开m个线程读，那么其时间复杂度为<code>O(max(n, (MAX/32)/m))</code>; 空间复杂度为<code>O(max(n, MAX/32))</code>。</p>
<h4 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h4><ul>
<li><p>优点</p>
<p>(1). 运算效率高，不进行数据比较；查找，去重存储效率高，不需要遍历全部数据就可以进行。</p>
<p>(2). 占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。</p>
<p>(3). 在数据量大且重复率少的情况下，可以极大程度的压缩存储空间，并且保证有序。</p>
<p>(4). 对于特定的，只有0，1特征值，并且含有唯一识别号的数据存储中，优势巨大，节省存储空间，查询和维护的成本。</p>
</li>
<li><p>缺点</p>
<p>(1). 所有的数据不能重复，即不可对重复的数据进行排序。（针对少量重复的数据，假设其重复次数为n，则 a = {n的平方根 + 1} 表示, 可以用a-bitmap算法。比如当a=5时，则利用3-bitmap算法）。</p>
<p>(2). 当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有<strong>当数据比较密集</strong>时才有优势。</p>
</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>Bitmap算法适用于：</p>
<ul>
<li>可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下；</li>
<li>去重数据而达到压缩数据；</li>
<li>用于爬虫系统中url去重、解决全组合问题；</li>
<li>Bitmap算法可以扩展为Bloom filter(布隆过滤器)。</li>
</ul>
<h4 id="问题-1：在2-5亿个整数中找出不重复的整数，约束条件时内存不足以容纳这2-5亿个整数。"><a href="#问题-1：在2-5亿个整数中找出不重复的整数，约束条件时内存不足以容纳这2-5亿个整数。" class="headerlink" title="问题 1：在2.5亿个整数中找出不重复的整数，约束条件时内存不足以容纳这2.5亿个整数。"></a>问题 1：在2.5亿个整数中找出不重复的整数，约束条件时内存不足以容纳这2.5亿个整数。</h4><p><strong>解法一：</strong>采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p><strong>解法二：</strong>也可采用进行划分小文件的方法，然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”</p>
<h4 id="问题-2：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#问题-2：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="问题 2：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>问题 2：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h4><p><strong>解法一：</strong>可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<h4 id="问题-3：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。"><a href="#问题-3：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。" class="headerlink" title="问题 3：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。"></a>问题 3：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</h4><p><strong>解法一：</strong>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）</p>
<h4 id="问题-4：给定一个数组a，求所有和为SUM的两个数。"><a href="#问题-4：给定一个数组a，求所有和为SUM的两个数。" class="headerlink" title="问题 4：给定一个数组a，求所有和为SUM的两个数。"></a>问题 4：给定一个数组a，求所有和为SUM的两个数。</h4><p><strong>解法一：</strong>如果数组都是整数（负数也可以，将所有数据加上最小的负数x，SUM += 2x就可以了）。如a = [1,2,3,4,7,8]，先求a的补数组[8,7,6,5,2,1]，开辟两个数组b1,b2（最大数组长度为SUM/8/2{因为两数满足和为SUM，一个数&lt;SUM/2，另一个数也就知道了}，这样每个b数组最大内存为SUM/(8<em>2</em>1024*1024) = 128M）,使用bitmap算法和数组a分别设置b1、b2对应的位为1，b1、b2相与就可以得到和为SUM的两个数其中一个数了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.07.html" target="_blank" rel="noopener">Bitmap 方法</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/chanshuyi/p/5287825.html" target="_blank" rel="noopener">BigMap 算法</a></p>
</li>
<li><a href="https://blog.csdn.net/pipisorry/article/details/64127666" target="_blank" rel="noopener">Bloom Filter 布隆过滤器</a></li>
</ul>
<hr>
<p>分享人：复旦大学NiSL <strong><em>周鑫   金力  黄一博</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/" data-id="cjnkcum6n001pdemx4a4d1t3s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sort/">Sort</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RDMA-Driven-Paxos-Consistent-Algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/" class="article-date">
  <time datetime="2018-10-15T04:24:53.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/每周技术分享/">每周技术分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/">RDMA-Driven Paxos Consistent Algorithm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下周即将分享，敬请期待。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/" data-id="cjnkcum4w0006demx6ewrjlmh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paxos/">Paxos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RDMA/">RDMA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Google-Protocol-Buffer-实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/Google-Protocol-Buffer-实践/" class="article-date">
  <time datetime="2018-09-17T23:16:54.000Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-C-编程/">C/C++编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/Google-Protocol-Buffer-实践/">Google Protocol Buffer 实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：<br>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<br>或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。</p>
</blockquote>
<h2 id="Google-Protocol-Buffer-Demo"><a href="#Google-Protocol-Buffer-Demo" class="headerlink" title="Google Protocol Buffer Demo"></a>Google Protocol Buffer Demo</h2><h3 id="安装Google-Protocol-Buffer"><a href="#安装Google-Protocol-Buffer" class="headerlink" title="安装Google Protocol Buffer"></a>安装Google Protocol Buffer</h3><p>在网站 <a href="http://code.google.com/p/protobuf/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/protobuf/downloads/list</a>上可以下载 Protobuf 的源代码。然后解压编译安装便可以使用它了。<br>安装步骤如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf protobuf-2.1.0.tar.gz</span><br><span class="line">cd protobuf-2.1.0</span><br><span class="line">./configure --prefix=$INSTALL_DIR</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h3 id="Demo描述"><a href="#Demo描述" class="headerlink" title="Demo描述"></a>Demo描述</h3><p>我打算使用 Protobuf 和 C++ 开发一个十分简单的例子程序。<br>该程序由两部分组成。第一部分被称为 Writer，第二部分叫做 Reader。<br>Writer 负责将一些结构化的数据写入一个磁盘文件，Reader 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。<br>准备用于演示的结构化数据是 HelloWorld，它包含两个基本数据：</p>
<ul>
<li>ID，为一个整数类型的数据</li>
<li>Str，这是一个字符串</li>
</ul>
<h3 id="创建编写-proto-文件"><a href="#创建编写-proto-文件" class="headerlink" title="创建编写.proto 文件"></a>创建编写.proto 文件</h3><p>首先我们需要编写一个 proto 文件，定义我们程序中需要处理的结构化数据，在 protobuf 的术语中，结构化数据被称为 Message。proto 文件非常类似 java 或者 C 语言的数据定义。代码清单 1 显示了例子应用中的 proto 文件内容。</p>
<p><strong>清单1.  lm.helloworld.proto</strong><br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// lm.helloworld.proto</span><br><span class="line">package lm;</span><br><span class="line">message helloworld</span><br><span class="line">&#123;</span><br><span class="line">   required int32     id = 1;  // ID</span><br><span class="line">   required string    str = 2;  // str</span><br><span class="line">   optional int32     opt = 3;  //optional field</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个比较好的习惯是认真对待 proto 文件的文件名。比如将命名规则定于如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packageName.MessageName.proto</span><br></pre></td></tr></table></figure>
<p>在上例中，package 名字叫做 lm，定义了一个消息 helloworld，该消息有三个成员，类型为 int32 的 id，另一个为类型为 string 的成员 str。opt 是一个可选的成员，即消息中可以不包含该成员。</p>
<h3 id="编译-proto-文件"><a href="#编译-proto-文件" class="headerlink" title="编译 .proto 文件"></a>编译 .proto 文件</h3><p>写好 proto 文件之后就可以用 Protobuf 编译器将该文件编译成目标语言了。本例中我们将使用 C++。<br>假设您的 proto 文件存放在 $SRC_DIR 下面，您也想把生成的文件放在同一个目录下，则可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto</span><br></pre></td></tr></table></figure>
<p>命令将生成两个文件：</p>
<ul>
<li>lm.helloworld.pb.h ， 定义了 C++ 类的头文件</li>
<li>lm.helloworld.pb.cc ， C++ 类的实现文件</li>
</ul>
<p>在生成的头文件中，定义了一个 C++ 类 helloworld，后面的 Writer 和 Reader 将使用这个类来对消息进行操作。诸如对消息的成员进行赋值，将消息序列化等等都有相应的方法。</p>
<h3 id="编写-writer-和-Reader"><a href="#编写-writer-和-Reader" class="headerlink" title="编写 writer 和 Reader"></a>编写 writer 和 Reader</h3><p>如前所述，Writer 将把一个结构化数据写入磁盘，以便其他人来读取。假如我们不使用 Protobuf，其实也有许多的选择。一个可能的方法是将数据转换为字符串，然后将字符串写入磁盘。转换为字符串的方法可以使用 sprintf()，这非常简单。数字 123 可以变成字符串”123”。<br>这样做似乎没有什么不妥，但是仔细考虑一下就会发现，这样的做法对写 Reader 的那个人的要求比较高，Reader 的作者必须了 Writer 的细节。比如”123”可以是单个数字 123，但也可以是三个数字 1,2 和 3，等等。这么说来，我们还必须让 Writer 定义一种分隔符一样的字符，以便 Reader 可以正确读取。但分隔符也许还会引起其他的什么问题。最后我们发现一个简单的 Helloworld 也需要写许多处理消息格式的代码。</p>
<p><strong>如果使用 Protobuf，那么这些细节就可以不需要应用程序来考虑了。</strong><br>使用 Protobuf，Writer 的工作很简单，需要处理的结构化数据由 .proto 文件描述，经过上一节中的编译过程后，该数据化结构对应了一个 C++ 的类，并定义在 lm.helloworld.pb.h 中。对于本例，类名为 lm::helloworld。<br>Writer 需要 include 该头文件，然后便可以使用这个类了。<br>现在，在 Writer 代码中，将要存入磁盘的结构化数据由一个 lm::helloworld 类的对象表示，它提供了一系列的 get/set 函数用来修改和读取结构化数据中的数据成员，或者叫 field。<br>当我们需要将该结构化数据保存到磁盘上时，类 lm::helloworld 已经提供相应的方法来把一个复杂的数据变成一个字节序列，我们可以将这个字节序列写入磁盘。<br>对于想要读取这个数据的程序来说，也只需要使用类 lm::helloworld 的相应反序列化方法来将这个字节序列重新转换会结构化数据。这同我们开始时那个“123”的想法类似，不过 Protobuf 想的远远比我们那个粗糙的字符串转换要全面，因此，我们不如放心将这类事情交给 Protobuf 吧。代码清单2列出了Writer的核心代码。</p>
<p><strong>清单2. Writer.cpp代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lm.helloworld.pb.h"</span></span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  lm::helloworld msg1;</span><br><span class="line">  msg1.set_id(<span class="number">101</span>);</span><br><span class="line">  msg1.set_str(“hello”);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">  <span class="function">fstream <span class="title">output</span><span class="params">(<span class="string">"./log"</span>, ios::out | ios::trunc | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!msg1.SerializeToOstream(&amp;output)) &#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write msg."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，Msg1 是一个 helloworld 类的对象，set_id() 用来设置 id 的值。SerializeToOstream 将对象序列化后写入一个 fstream 流。</p>
<p>代码清单 3 列出了 reader 的主要代码。<br><strong>清单2. Reader.cpp代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lm.helloworld.pb.h"</span></span></span><br><span class="line">…</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ListMsg</span><span class="params">(<span class="keyword">const</span> lm::helloworld &amp; msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lm::helloworld msg1;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(<span class="string">"./log"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!msg1.ParseFromIstream(&amp;input)) &#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse address book."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListMsg(msg1);</span><br><span class="line">  …</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，Reader 声明类 helloworld 的对象 msg1，然后利用 ParseFromIstream 从一个 fstream 流中读取信息并反序列化。此后，ListMsg 中采用 get 方法读取消息的内部信息，并进行打印输出操作。</p>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行 Writer 和 Reader 的结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;writer</span><br><span class="line">&gt;reader</span><br><span class="line">101</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p>
<p>Reader 读取文件 log 中的序列化信息并打印到屏幕上。</p>
<p><strong>这个例子本身并无意义，但只要您稍加修改就可以将它变成更加有用的程序。比如将磁盘替换为网络 socket，那么就可以实现基于网络的数据交换任务。而存储和交换正是 Protobuf 最有效的应用领域。</strong></p>
<h2 id="和其他类似技术的比较"><a href="#和其他类似技术的比较" class="headerlink" title="和其他类似技术的比较"></a>和其他类似技术的比较</h2><p><strong>看完这个简单的例子之后，希望您已经能理解 Protobuf 能做什么了，那么您可能会说，世上还有很多其他的类似技术啊，比如 XML，JSON，Thrift 等等。和他们相比，Protobuf 有什么不同呢？</strong></p>
<p>简单说来 Protobuf 的主要优点就是：简单，快。<br>这有测试为证，项目 thrift-protobuf-compare 比较了这些类似的技术，图 1 显示了该项目的一项测试结果，Total Time.</p>
<div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-e42d037868db93e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/2000" alt="图1 性能测试结果"><br></div>

<p>Total Time 指一个对象操作的整个时间，包括创建对象，将对象序列化为内存中的字节序列，然后再反序列化的整个过程。从测试结果可以看到 Protobuf 的成绩很好，感兴趣的读者可以自行到网站 [<a href="https://github.com/eishay/jvm-serializers/wiki)上了解更详细的测试结果。" target="_blank" rel="noopener">https://github.com/eishay/jvm-serializers/wiki)上了解更详细的测试结果。</a></p>
<h3 id="Protobuf-的优点"><a href="#Protobuf-的优点" class="headerlink" title="Protobuf 的优点"></a>Protobuf 的优点</h3><ul>
<li><p>Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p>
</li>
<li><p>它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。</p>
</li>
<li><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p>
</li>
<li><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p>
</li>
</ul>
<h3 id="Protobuf-的不足"><a href="#Protobuf-的不足" class="headerlink" title="Protobuf 的不足"></a>Protobuf 的不足</h3><ul>
<li><p>Protbuf 与 XML 相比也有不足之处。它功能简单，无法用来表示复杂的概念。</p>
</li>
<li><p>XML 已经成为多种行业标准的编写工具，Protobuf 只是 Google 公司内部使用的工具，在通用性上还差很多。</p>
</li>
<li><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。</p>
</li>
</ul>
<h2 id="高级应用话题"><a href="#高级应用话题" class="headerlink" title="高级应用话题"></a>高级应用话题</h2><h3 id="更复杂的-Message"><a href="#更复杂的-Message" class="headerlink" title="更复杂的 Message"></a>更复杂的 Message</h3><p>到这里为止，我们只给出了一个简单的没有任何用处的例子。在实际应用中，人们往往需要定义更加复杂的 Message。我们用“复杂”这个词，不仅仅是指从个数上说有更多的 fields 或者更多类型的 fields，而是指更加复杂的数据结构：</p>
<ul>
<li><p><strong>嵌套 Message</strong></p>
<p>代码清单 4 给出一个嵌套 Message 的例子。</p>
</li>
</ul>
<p><em>清单 4. 嵌套 Message 的例子</em><br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line"> required string name = 1;</span><br><span class="line"> required int32 id = 2;        // Unique ID number for this person.</span><br><span class="line"> optional string email = 3;</span><br><span class="line"></span><br><span class="line"> enum PhoneType &#123;</span><br><span class="line">   MOBILE = 0;</span><br><span class="line">   HOME = 1;</span><br><span class="line">   WORK = 2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> message PhoneNumber &#123;</span><br><span class="line">   required string number = 1;</span><br><span class="line">   optional PhoneType type = 2 [default = HOME];</span><br><span class="line"> &#125;</span><br><span class="line"> repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Message Person 中，定义了嵌套消息 PhoneNumber，并用来定义 Person 消息中的 phone 域。这使得人们可以定义更加复杂的数据结构。</p>
<ul>
<li><p><strong>Import Message</strong></p>
<p>在一个 .proto 文件中，还可以用 Import 关键字引入在其他 .proto 文件中定义的消息，这可以称做 Import Message，或者 Dependency Message。例子如下所示：<br><strong>清单 5. Import Message</strong></p>
</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import common.header;</span><br><span class="line"></span><br><span class="line">message youMsg&#123;</span><br><span class="line"> required common.info_header header = 1;</span><br><span class="line"> required string youPrivateData = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 ,common.info_header定义在common.header包内。</p>
<blockquote>
<p>Import Message 的用处主要在于提供了方便的代码管理机制，类似 C 语言中的头文件。您可以将一些公用的 Message 定义在一个 package 中，然后在别的 .proto 文件中引入该 package，进而使用其中的消息定义。<br>Google Protocol Buffer 可以很好地支持嵌套 Message 和引入 Message，从而让定义复杂的数据结构的工作变得非常轻松愉快。</p>
</blockquote>
<h3 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h3><p>一般情况下，使用 Protobuf 的人们都会先写好 .proto 文件，再用 Protobuf 编译器生成目标语言所需要的源代码文件。将这些生成的代码和应用程序一起编译。</p>
<p>可是在某且情况下，人们无法预先知道 .proto 文件，他们需要动态处理一些未知的 .proto 文件。比如一个通用的消息转发中间件，它不可能预知需要处理怎样的消息。这需要动态编译 .proto 文件，并使用其中的 Message。</p>
<p><strong>Protobuf 提供了 google::protobuf::compiler 包来完成动态编译的功能。主要的类叫做 importer，定义在 importer.h 中。使用 Importer 非常简单，下图展示了与 Import 和其它几个重要的类的关系。</strong></p>
<div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-9166113b95e5d7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/2000" alt="图 2. Importer 类"><br></div>

<p>首先构造一个 importer 对象。构造函数需要两个入口参数，一个是 source Tree 对象，该对象指定了存放 .proto 文件的源目录。第二个参数是一个 error collector 对象，该对象有一个 AddError 方法，用来处理解析 .proto 文件时遇到的语法错误。<br>之后，需要动态编译一个 .proto 文件时，只需调用 importer 对象的 import 方法。非常简单。</p>
<p>那么我们如何使用动态编译后的 Message 呢？我们需要首先了解几个其他的类。<br>Package google::protobuf::compiler 中提供了以下几个类，用来表示一个 .proto 文件中定义的 message，以及 Message 中的 field，如图3所示。</p>
<div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-57028764b0d9dc88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 3. 各个 Compiler 类之间的关系"><br></div>

<p>类 FileDescriptor 表示一个编译后的 .proto 文件；类 Descriptor 对应该文件中的一个 Message；类 FieldDescriptor 描述一个 Message 中的一个具体 Field。</p>
<p>比如编译完 lm.helloworld.proto 之后，可以通过如下代码得到 lm.helloworld.id 的定义：</p>
<p><strong>清单 7. 得到 lm.helloworld.id 的定义的代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protobuf::Descriptor *desc =</span><br><span class="line">   importer_.pool()-&gt;FindMessageTypeByName(“lm.helloworld”);</span><br><span class="line"><span class="keyword">const</span> protobuf::FieldDescriptor* field =</span><br><span class="line">   desc-&gt;pool()-&gt;FindFileByName (“id”);</span><br></pre></td></tr></table></figure></p>
<p>通过 Descriptor，FieldDescriptor 的各种方法和属性，应用程序可以获得各种关于 Message 定义的信息。比如通过 field-&gt;name() 得到 field 的名字。这样，您就可以使用一个动态定义的消息了。</p>
<h3 id="编写新的-proto-编译器"><a href="#编写新的-proto-编译器" class="headerlink" title="编写新的 proto 编译器"></a>编写新的 proto 编译器</h3><p>随 Google Protocol Buffer 源代码一起发布的编译器 protoc 支持 3 种编程语言：C++，java 和 Python。但使用 Google Protocol Buffer 的 Compiler 包，您可以开发出支持其他语言的新的编译器。</p>
<p>类 CommandLineInterface 封装了 protoc 编译器的前端，包括命令行参数的解析，proto 文件的编译等功能。您所需要做的是实现类 CodeGenerator 的派生类，实现诸如代码生成等后端工作：</p>
<p>程序的大体框架如图所示：</p>
<div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-440e574a983f7da8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 4. XML 编译器框图"><br></div>

<p>在 main() 函数内，生成 CommandLineInterface 的对象 cli，调用其 RegisterGenerator() 方法将新语言的后端代码生成器 yourG 对象注册给 cli 对象。然后调用 cli 的 Run() 方法即可。</p>
<p>这样生成的编译器和 protoc 的使用方法相同，接受同样的命令行参数，cli 将对用户输入的 .proto 进行词法语法等分析工作，最终生成一个语法树。该树的结构如图所示。</p>
<p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-00e1d92873b596e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/2000" alt="图 5. 语法树"><br></div><br>其根节点为一个 FileDescriptor 对象（请参考“动态编译”一节），并作为输入参数被传入 yourG 的 Generator() 方法。在这个方法内，您可以遍历语法树，然后生成对应的您所需要的代码。简单说来，要想实现一个新的 compiler，您只需要写一个 main 函数，和一个实现了方法 Generator() 的派生类即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/09/18/Google-Protocol-Buffer-实践/" data-id="cjnkcum6m001odemxg5q5a9wn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C-编程/">C/C++编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C语言中snprintf-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/08/C语言中snprintf-函数/" class="article-date">
  <time datetime="2018-06-07T23:24:28.000Z" itemprop="datePublished">2018-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-C-编程/">C/C++编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/C语言中snprintf-函数/">C语言中snprintf()函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><strong>函数原型</strong>：<figure class="highlight plain"><figcaption><span>snprintf(char* dest_str,size_t size,const char* format,...);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- **函数功能**：先将可变参数 “...” 按照format的格式格式化为字符串，然后再将其拷贝至dest_str中。</span><br><span class="line">- **头文件**：#include&lt;stdio.h&gt;</span><br><span class="line">- **注意事项**：</span><br><span class="line">  - 如果如果格式化后的字符串长度小于size，则将字符串全部拷贝至dest_str中，并在字符串结尾处加上‘\0’；</span><br><span class="line">  - 如果格式化后的字符串长度大于或等于size，则将字符串的(size-1)拷贝至dest_str中，然后在字符串结尾处加上&apos;\0&apos;.</span><br><span class="line">  - 函数返回值是 格式化字符串的长度。</span><br><span class="line">- **使用示例**：</span><br><span class="line"></span><br><span class="line">``` C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char  *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">  char test_str[4096];</span><br><span class="line">  memset(test_str, 0, sizeof(test_str));</span><br><span class="line"></span><br><span class="line">  char *str_1 = &quot;复旦大学&quot;;</span><br><span class="line">  int size = strlen(str_1);</span><br><span class="line">  char *name = &quot;Bob Huang&quot;;</span><br><span class="line">  int year = 2018;</span><br><span class="line">  int month = 6;</span><br><span class="line">  int day = 8;</span><br><span class="line"></span><br><span class="line">  snprintf(test_str, sizeof(test_str), &quot;学校:%s\n名字:%s\nToday:%d年%d月%d日\n&quot;, str_1, name, year, month, day);</span><br><span class="line"></span><br><span class="line">  printf(&quot;%s\n&quot;, test_str);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p><strong>运行结果</strong>：<br><img src="https://upload-images.jianshu.io/upload_images/2639937-76cefee205c8240a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/06/08/C语言中snprintf-函数/" data-id="cjnkcum4r0002demxg9ree0fu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C-编程/">C/C++编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Makefile中-PHONY的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/08/Makefile中-PHONY的使用/" class="article-date">
  <time datetime="2018-06-07T23:23:18.000Z" itemprop="datePublished">2018-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-C-编程/">C/C++编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/Makefile中-PHONY的使用/">Makefile中.PHONY的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在C项目构建中，经常在Makefile文件中用到.PHONY配置项。.PHONY配置项的主要作用在于避免指定命令和项目下的同名文件冲突，进行性能优化。.PHONY [command name] 显式指定了一个命令名称【而不是实际文件名】，是为了避免该命令名称与makefile同路径下的文件名重名冲突，以使make [command name]命令可以正确被解析、执行。下面将举例说明。</p>
</blockquote>
<h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><p>如果编写一个规则名称为<code>clean</code>，不产生目标文件，那么该命令在执行<code>make clean</code>时规则都会被执行，makefile内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -f *.o temp</span><br></pre></td></tr></table></figure></p>
<p> rm 命令不产生任何clean文件。</p>
<ul>
<li>如果目录下不存在名为”clean”的文件，则运行<code>make clean</code>时，命令都会正常执行；</li>
<li>如果目录下存在名为”clean”的文件，则运行<code>make clean</code>时，命令规则会失效，文件”clean”没有依赖文件，始终是最新的，<code>make clean</code>永远不会被执行。<br>为了解决上述问题，可以使用<code>.PHONY clean</code>指明该clean命令。如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f *.o temp</span><br></pre></td></tr></table></figure>
<p>这样执行命令<code>make clean</code>会自动忽略名为”clean”文件的存在。已知<code>.PHONY</code>配置项的目标并不是其他文件生成的实际文件，make命令会自动绕过隐含规则搜索过程，因此声明.PHONY配置项会改善性能，bi且不需要担心实际同名文件存在与否。</p>
<h3 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h3><p>如果.PHONY目标有依赖关系。当一个目录中存在多个可运行程序，将其配置在同一个makefile文件。由于<code>make [command name/ Default command]</code>默认缺省规则是makefile文件中的第一个规则，一般将这第一个规则称为<strong>“all”</strong>，其依赖文件为多个可运行程序，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all:  p1 p2 p3</span><br><span class="line">.PHONY: all</span><br><span class="line">p1:  p1.o utils.o</span><br><span class="line">       cc -o p1 p1.o utils.o</span><br><span class="line">p2:  p2.o utils.o</span><br><span class="line">       cc -o p2 p2.o utils.o</span><br><span class="line">p3:  p3.o utils.o</span><br><span class="line">       cc -o p3 p3.o utils.o</span><br></pre></td></tr></table></figure></p>
<p>  其中p1、p2和p3是三个可执行文件，make把<strong>“all”</strong>作为主要规则，每次执行时都尝试把”all”更新，因此会检查其依赖文件p1、p2和p3是否需要更新，如果需要，就把它们更新，从而达到我们的目的。通过.PHONY指定目标为all，可以避免目录下同名文件的干扰，即不用检查规则”all”是否有同名文件存在，也不需要查询任何隐含规则，直接假定指定的规则”all”需要被更新。</p>
<hr>
<p><strong>综上所述，<code>.PHONY</code>是一个伪目标，可以有效防止在Makefile文件中定义的可执行命令的目标规则和工作目录下的实际文件出现名称冲突，并提高了执行Makefile的性能。</strong></p>
<hr>
<p>Bob Huang<br>2018.0608</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2018/06/08/Makefile中-PHONY的使用/" data-id="cjnkcum4v0005demx6jlku7s0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C-编程/">C/C++编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web网站高并发量的解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/04/Web网站高并发量的解决方案/" class="article-date">
  <time datetime="2016-08-03T23:03:38.000Z" itemprop="datePublished">2016-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/架构/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/04/Web网站高并发量的解决方案/">Web网站高并发量的解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h3><p>  一个小型的网站，可以使用最简单的html静态页面就实现了，配合一些图片达到美化效果，所有的页面均存放在一个目录下，这样的网站对系统架构、性能的要求都很简单。随着互联网业务的不断丰富，网站相关的技术经过这些年的发展，已经细分到很细的方方面面，尤其对于大型网站来说，所采用的技术更是涉及面非常广，从硬件到软件、编程语言、数据库、WebServer、防火墙等各个领域都有了很高的要求，已经不是原来简单的html静态网站所能比拟的。<br>  大型网站，比如门户网站，在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。这几个解决思路在一定程度上意味着更大的投入。</p>
<h3 id="HTML静态化"><a href="#HTML静态化" class="headerlink" title="HTML静态化"></a><strong>HTML静态化</strong></h3><p>　　其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统CMS，像我们常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。<br>　　除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化、有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。<br>　　同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现。比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储在数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。</p>
<h3 id="图片服务器分离"><a href="#图片服务器分离" class="headerlink" title="图片服务器分离"></a><strong>图片服务器分离</strong></h3><p>　　大家知道，对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的、甚至很多台的图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃。<br>　　在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持、尽可能少的LoadModule，保证更高的系统消耗和执行效率。</p>
<h3 id="数据库集群、库表散列"><a href="#数据库集群、库表散列" class="headerlink" title="数据库集群、库表散列"></a><strong>数据库集群、库表散列</strong></h3><p>　　大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表散列。<br>　　在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是类似的方案，您使用了什么样的DB，就参考相应的解决方案来实施即可。<br>　　上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用DB类型的限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并且最有效的解决方案。<br>　　我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。<br>　　sohu的论坛就是采用了这样的架构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板块和ID进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系统随时增加一台低成本的数据库进来补充系统性能。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h3><p>　　缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。这里先讲述最基本的两种缓存。高级和分布式的缓存在后面讲述。<br>　　架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。<br>　　网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，.net不是很熟悉，相信也肯定有。</p>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a><strong>镜像</strong></h3><p>　　镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>　　负载均衡将是大型网站解决高负荷访问和大量并发请求采用的高端解决办法。　　负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择，我个人接触过一些解决方法，其中有两个架构可以给大家做参考。<br>（1）、硬件四层交换<br>　　第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。<br>　　第四层交换功能就像是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、TCP和UDP端口共同决定。<br>　　在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。“Yahoo中国”当初接近2000台服务器，只使用了三、四台Alteon就搞定了。<br>(2)、软件四层交换<br>　　大家知道了硬件四层交换机的原理后，基于OSI模型来实现的软件四层交换也就应运而生，这样的解决方案实现的原理一致，不过性能稍差。但是满足一定量的压力还是游刃有余的，有人说软件实现方式其实更灵活，处理能力完全看你配置的熟悉能力。<br>　　软件四层交换我们可以使用Linux上常用的LVS来解决，LVS就是Linux Virtual Server，他提供了基于心跳线heartbeat的实时灾难应对解决方案，提高系统的强壮性，同时可供了灵活的虚拟VIP配置和管理功能，可以同时满足多种应用需求，这对于分布式的系统来说必不可少。<br>　　一个典型的使用负载均衡的策略就是，在软件或者硬件四层交换的基础上搭建squid集群，这种思路在很多大型网站包括搜索引擎上被采用，这样的架构低成本、高性能还有很强的扩张性，随时往架构里面增减节点都非常容易。<br>　　对于大型网站来说，前面提到的每个方法可能都会被同时使用到，这里介绍得比较浅显，具体实现过程中很多细节还需要大家慢慢熟悉和体会。有时一个很小的squid参数或者apache参数设置，对于系统性能的影响就会很大。</p>
<h3 id="最新：CDN加速技术"><a href="#最新：CDN加速技术" class="headerlink" title="最新：CDN加速技术"></a><strong>最新：CDN加速技术</strong></h3><p>　　 CDN的全称是内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br>　　CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。<br>CDN的类型特点<br>　 　CDN的实现分为三类：镜像、高速缓存、专线。<br>　　镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。<br>　　高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。<br>　　CDN服务一般会在全国范围内的关键节点上放置缓存服务器。<br>　　专线，让用户直接访问数据源，可以实现数据的动态同步。<br><strong>CDN的实例</strong><br>　　举个例子来说，当某用户访问网站时，网站会利用全球负载均衡技术，将用户的访问指向到距离用户最近的正常工作的缓存服务器上，直接响应用户的请求。<br>　　当用户访问已经使用了CDN服务的网站时，其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地DNS的解析请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。<br>　　通过用户定位算法和服务器健康检测算法综合后的数据，可以将用户的请求就近定向到分布在网络“边缘”的缓存服务器上，保证用户的访问能得到更及时可靠的响应。<br>　　由于大量的用户访问都由分布在网络边缘的CDN节点缓存服务器直接响应了，这就不仅提高了用户的访问质量，同时有效地降低了源服务器的负载压力。</p>
<hr>
<p>Bobo<br>20160804</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2016/08/04/Web网站高并发量的解决方案/" data-id="cjnkcum5i000pdemx1bn3x06w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-WEB/">JAVA WEB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序猿/">程序猿</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-提高程序员编程效率的好习惯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/04/提高程序员编程效率的好习惯/" class="article-date">
  <time datetime="2016-08-03T22:56:52.000Z" itemprop="datePublished">2016-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/闲思碎语/">闲思碎语</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/04/提高程序员编程效率的好习惯/">提高程序员编程效率的好习惯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="只做需要做的工作"><a href="#只做需要做的工作" class="headerlink" title="只做需要做的工作"></a>只做需要做的工作</h3><p>使用敏捷方法；</p>
<p>全心全意做UX设计；</p>
<p>沟通第一；</p>
<p>编码也许不是解决问题的办法；</p>
<p>过早的优化是一切罪恶的根源；</p>
<p>选择最简单的解决方案。</p>
<h3 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h3><p>使用开源框架；</p>
<p>使用简洁语言；</p>
<p>不要做重复的事情（不要重新发明轮子）；</p>
<p>利用包管理器来进行公共和私有代码分配；</p>
<p>不要任凭巨头（如微软）的摆布而修复库中的一个Bug；</p>
<p>不要让你的雇主逼你学习；</p>
<p>自主学习并为自己设定新的目标。</p>
<h3 id="了解数据结构和算法"><a href="#了解数据结构和算法" class="headerlink" title="了解数据结构和算法"></a>了解数据结构和算法</h3><p>如果你不知道什么时候应该使用快速排序、不懂辨认O(n2)程序、不会写递归函数，你将无法成为10倍效率的开发者。使用多种语言你才能清楚不同的框架是如何解决相同问题的。尽可能去了解底层命令（plumbing），以便能够作出明智的决定（Web框架是怎么存储session状态的？Cookie到底是什么？）。</p>
<h3 id="不要怕买工具，它可以节省你的时间"><a href="#不要怕买工具，它可以节省你的时间" class="headerlink" title="不要怕买工具，它可以节省你的时间"></a>不要怕买工具，它可以节省你的时间</h3><p>Ben说：“昨天我花50美元买了一个位图字体工具，它帮我节省的时间成本绝对超过200美元。”</p>
<h3 id="集中注意力"><a href="#集中注意力" class="headerlink" title="集中注意力"></a>集中注意力</h3><p>不要整天开着你的电子邮件、Twitter、Facebook等，在工作时将它们最小化或关掉它们，戴上耳机。Tiny hack说：“即使不听音乐我也戴着耳机工作，这样便不会有人打扰到我。”</p>
<h3 id="尽早并且经常性地进行代码重构"><a href="#尽早并且经常性地进行代码重构" class="headerlink" title="尽早并且经常性地进行代码重构"></a>尽早并且经常性地进行代码重构</h3><p>有时，你不得不放弃漂亮的代码转而去寻找真正对项目有用的代码，但没关系，如果你的现有项目中有这样的代码，最好的方式便是不要看它，并重构。</p>
<h3 id="只管去做"><a href="#只管去做" class="headerlink" title="只管去做"></a>只管去做</h3><p>将你的业余项目分享到Startup Weekend中。在我开始转到Unix和Ruby on Rails上之前，我买了一台Mac，使用Windows虚拟机花了一年时间做.NET项目。</p>
<h3 id="挑选一个编辑器，并掌握它"><a href="#挑选一个编辑器，并掌握它" class="headerlink" title="挑选一个编辑器，并掌握它"></a>挑选一个编辑器，并掌握它</h3><p>高效开发者喜欢用文本编辑器胜过IDE编辑器，因为这样可以学到更多东西。无论什么情况，尽量使用键盘快捷键，因为熟练使用一件工具的前提是熟悉它。</p>
<p>在选择编辑器时，认真考虑并挑选最好的（Emacs或Vim），因为它们是通用的。其次，挑选你的首选平台最支持的。使用宏，不断地写代码；使用Mac上的TextExpander为整个段落创建快捷方式；使用Visual Studio或SublimeText的自动补齐功能；使用支持按行/列分割窗口的编辑器，这样你便能同时看到单元测试和代码（或模型、视图）。</p>
<p>一定要想清楚后再写代码。Adam说，“我有朋友在一个大项目组里工作，他们组里最高效的程序员是一个高位截瘫用嘴叼着棍子敲代码的人，他总是在写代码之前想得很仔细且很少出错。”</p>
<h3 id="整洁的代码胜过巧妙的代码"><a href="#整洁的代码胜过巧妙的代码" class="headerlink" title="整洁的代码胜过巧妙的代码"></a>整洁的代码胜过巧妙的代码</h3><p>要想让其他人能够读懂你的代码，尽量使用最少的代码来完成任务。遵循DRY（Don’t repeat yourself）的原则，使用明确定义的对象和库，将任务分解成小而简单的代码段。</p>
<h3 id="潜意识是强大的工具"><a href="#潜意识是强大的工具" class="headerlink" title="潜意识是强大的工具"></a>潜意识是强大的工具</h3><p>离开10分钟往往就可以解决一个问题。控制编程时间，给自己一个多姿多彩的生活，劳逸结合能让你在工作时更高效、更愉悦。当然，即便是上了年纪的程序员也知道，以最少的时间完成最高效的工作是成为10倍效率开发者的必要条件。</p>
<p>作为一个程序员，我觉得在职业生涯中最好的一件事儿就是从电脑前站起来，去拜访那些在某一领域有所建树的人们。</p>
<h3 id="推动自身和团队进步"><a href="#推动自身和团队进步" class="headerlink" title="推动自身和团队进步"></a>推动自身和团队进步</h3><p>重视批评，以包容的态度接受批评并提升自己是非常重要的事情。没有这个基础，你不可能成为一个高效的开发者。一位智者曾经说过：“聪明的人善于从自己的错误中学习，而智慧的人善于从别人的错误中学习。”</p>
<hr>
<p>Bob<br>20160804</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://huangyibo.github.io/2016/08/04/提高程序员编程效率的好习惯/" data-id="cjnkcum4n0001demxtug5pz6a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序猿/">程序猿</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-编程/">C/C++编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/每周技术分享/">每周技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/闲思碎语/">闲思碎语</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C-编程/">C/C++编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-WEB/">JAVA WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paxos/">Paxos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Producer-Customer/">Producer-Customer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDMA/">RDMA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/REST-API/">REST API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sort/">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System-Primitive/">System Primitive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/程序猿/">程序猿</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统原语/">系统原语</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/C-C-编程/" style="font-size: 16.67px;">C/C++编程</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JAVA-WEB/" style="font-size: 13.33px;">JAVA WEB</a> <a href="/tags/Paxos/" style="font-size: 10px;">Paxos</a> <a href="/tags/Producer-Customer/" style="font-size: 13.33px;">Producer-Customer</a> <a href="/tags/RDMA/" style="font-size: 10px;">RDMA</a> <a href="/tags/REST-API/" style="font-size: 10px;">REST API</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/System-Primitive/" style="font-size: 13.33px;">System Primitive</a> <a href="/tags/程序猿/" style="font-size: 13.33px;">程序猿</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/系统原语/" style="font-size: 13.33px;">系统原语</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/22/test/">test</a>
          </li>
        
          <li>
            <a href="/2018/10/22/System-Primitive-系统原语-的基本原理与实践/">System Primitive(系统原语)的基本原理与实践</a>
          </li>
        
          <li>
            <a href="/2018/10/22/System-Primitive的基本原理与实践/">System Primitive的基本原理与实践</a>
          </li>
        
          <li>
            <a href="/2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/">Bitmap算法:一种基于bit位的数据排序、查重艺术</a>
          </li>
        
          <li>
            <a href="/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/">RDMA-Driven Paxos Consistent Algorithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Bob Huang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>