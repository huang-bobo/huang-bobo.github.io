{"meta":{"title":"Bobo Huang写字的地方","subtitle":null,"description":null,"author":"Bob Huang","url":"http://yoursite.com"},"pages":[{"title":"About Me","date":"2018-10-15T05:49:56.000Z","updated":"2018-10-16T00:00:36.514Z","comments":true,"path":"About/index.html","permalink":"http://yoursite.com/About/index.html","excerpt":"","text":"我荒废的今日，正式昨日殒身之人祈求的明日！ I am Bob Huang, CS phd in Fudan University. Now I am interested in RDMA-based System Optimization and Application Innovation! Welcome to My Blog Site!"},{"title":"标签云","date":"2018-10-15T06:04:27.000Z","updated":"2018-10-15T21:42:42.518Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Bitmap算法:一种基于bit位的数据排序、查重艺术","slug":"Bitmap算法-一种基于bit位的数据排序、查重艺术","date":"2018-10-15T21:23:09.000Z","updated":"2018-10-15T22:25:19.151Z","comments":true,"path":"2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/","link":"","permalink":"http://yoursite.com/2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/","excerpt":"","text":"随着大数据规模的逐渐增长，在单机上的海量数据条目排序、查重、压缩是一项很有挑战性的工作。随之而来的许多硬件加速技术、算法被提出来，并在生产环境中落地实践，Bitmap就是其中一种被普遍应用的大数据排序、查重的算法，该算法巧妙利用了bit位来表示一个数值在一组数据集合中的状态（如某元素是否存在数据集合中），极大地压缩了数据处理（排序、查重）所需要的内存空间。本文将从算法概述、基本原理与实现、算法评估、应用场景与实例四个方面进行阐述。 算法概述Bitmap（位图算法），是一种基于bit的映射算法，即用一个bit位（或几个bit位）来标记某个元素对应的状态value，而key即是该元素，对应的value即是该元素key的状态（0表示key不存在，1表示key存在），当然也可以根据需要选择多个bit位表示，2个bit标识4种状态，3个bit标识8种状态，n个bit标识2^n种状态。 由此产生了Bitmap位图数据结构。该数据结构描述了一个有限定义域内的稠密集合，其中（1）每一个元素最多出现一次；（2）并且没有其他任何数据与该元素相关联。即使这些条件没有完全满足（例如，存在重复元素或额外的数据），也可以用有限定义域内的键作为一个表项更复杂的表格的索引。 由于采用bit位存储数据，对于海量数据的查重、排序问题，可以大大节省所需内存存储空间，Bitmap算法适用于解决数据集中的每个元素最多出现一次（或n次）并且没有其他任何数据与该元素相关联的问题。 基本原理与实现Bitmap算法基本原理一个整型数据，比如int a;,在内存中占用32bit，可以用对应的32bit位对应十进制的0-31个数，bitmap算法利用这种思想处理大量数据的排序和查询。 我们举个例子，现在有一个无序有界int数组int[] b = {5,2,11,3},至少需要占用内存4*4=16个字节，但是如果有10亿个这样的数，大概需要1000000000*4/(1024*1024*1024)=3.72GB左右，如果针对这样大量的数据进行查询排序，内存肯定要溢出崩溃的。 针对上面的问题，使用Bitmap算法就可以轻易解决，一个byte占用8个bit，如果用bit的位置索引表示数组b中的元素值，bit位的取值（0或1）表示该元素在数组中的状态（是否存在），0表示不存在，1表示存在。那么整个过程如下所示： 申请一个int型（根据需要也可以申请long型或short型）的内存空间，则有4个Byte，共32bit。然后根据数组下标int[] b = {5,2,11,3}依次遍历5,2,11,3， 把相应的bit位置为1，表示该元素存在。其中，bit区域从低bit位到高bit位，对应的位置索引i即代表要标识的数组int[] b中元素值，bit位为1表示该元素存在数组中，默认为0表示元素不存在： 输入5，将相应的第 6 bit置为1： 输入2，将相应的第 3 bit置为1: 输入11，将相应的第 12 bit置为1: 输入3，将相应的第 4 bit置为1: Bitmap算法的基本原理很简单巧妙，关键是十进制和二进制bit之间的转换需要一个映射表，一方面在数据组装初始化时，需要将10进制数据映射到相应的bit位上；另一方面，在遍历一片bit区域时，需要将bit位信息解析为10进制数据及状态（有或无）。 Map映射表假设需要排序或者查重的整型数的总数N=10000000=10^7, 那么我们需要申请内存空间的大小为int a[1 + N/32](或者long long a[1 + N/64]),其中a[0]在内存中占用32bit，依次类推bitmap表如下： 12345678a[0] --------&gt; 0 ~ 31a[1] --------&gt; 32 ~ 63a[2] --------&gt; 64 ~ 95a[3] --------&gt; 96 ~ 127......a[312500] --------&gt; (10^7) ~ (10^7 + 31)......a[N/32] --------&gt; (N/32)*32 ~ ((N/32) * 32 + 31) Bit位移转换为了得到Map映射表，我们需要利用bit位移将10进制数转换位2进制bit位。 求十进制数 0 - n 对应的在数组 a 中的下标： index_loc = n / 32，32表示int型占用的32bit，index_loc即为n对应的数组下标。例如n = 80 , 则index_loc = 80 / 32 = 2, 因此n = 80在a[2]中。 求十进制数 0 - n 对应的bit位: bit_loc = N % 32，例如 n = 80, bit_loc = 80 % 32 = 16。 利用移位运算 0 - 31 使得a[index_loc]对应的32bit位为1. Bitmap算法实现（C语言）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SHIFT 5#define MASK 0x1F/** * 设置所在的bit位为1 * * T = O(1) * */void set(int n, int *arr)&#123; int index_loc, bit_loc; index_loc = n &gt;&gt; SHIFT; // 等价于n / 32 bit_loc = n &amp; MASK; // 等价于n % 32 。 h%2^n = h &amp; (2^n -1) arr[index_loc] |= 1 &lt;&lt; bit_loc;&#125;// 上述set函数等价于//void set(int i)//&#123;// a[i/32] |= (1&lt;&lt;(i%32));//&#125;/** * 初始化arr[index_loc]所有bit位为0 * * T = O(1) * */void clr(int n, int *arr)&#123; int index_loc; index_loc = n &gt;&gt; SHIFT; arr[index_loc] &amp;= 0;&#125;/** * 测试n所在的bit位是否为1 * * T = O(1) * */int test(int n, int *arr)&#123; int i, flag; i = 1 &lt;&lt; (n &amp; MASK); flag = arr[n &gt;&gt; SHIFT] &amp; i; return flag;&#125;int main(void)&#123; int i, num, space, *arr; while (scanf(\"%d\", &amp;num) != EOF) &#123; // 确定大小&amp;&amp;动态申请数组 space = num / 32 + 1; arr = (int *)malloc(sizeof(int) * space); // 初始化bit位为0 for (i = 0; i &lt;= num; i ++) clr(i, arr); // 设置num的比特位为1 set(num, arr); // 测试 if (test(num, arr)) &#123; printf(\"成功！\\n\"); &#125; else &#123; printf(\"失败!\\n\"); &#125; &#125; return 0;&#125; 以下将对上述代码进行解析： i&gt;&gt;SHIFT(相当于整除运算i/32，保留商) 其中SHIFT = 5，即i右移5bit，2^5=32,相当于i/32，即求出十进制i对应在数组a中的下标index_loc。比如i=20，通过i&gt;&gt;SHIFT=20&gt;&gt;5=0 可求得i=20的下标为0； i &amp; MASK (相当于取模运算i%32，保留余数) 其中MASK=0X1F,十六进制转化为十进制为31，二进制为0001 1111，i &amp;（0001 1111）相当于保留i的后5位。 比如i=23，二进制为：0001 0111，那么 0001 0111 &amp; 0001 1111 = 0001 0111 十进制为：23; 比如i=83，二进制为：0000 0000 0101 0011，那么 `0000 0000 0101 0011 &amp; 0000 0000 0001 0000 = 0000 0000 0001 1111` 十进制为：19 . 1&lt;&lt;(i &amp; MASK) 相当于把1左移 (i &amp; MASK)位, 比如(i &amp; MASK)=20，那么i&lt;&lt;20就相当于： `0000 0000 0000 0000 0000 0000 0000 0001 &gt;&gt;20 =0000 0000 0000 1000 0000 0000 0000 0000 ` - 算法评估复杂度分析 对于数据规模为n的整型数据集，Bitmap算法的时间复杂度为O(n), 空间复杂度为O(1)。 其中，存储bit位信息的数组a大小由最大数max决定。即size_of(a) = max_of(b), 其中b表示原始数据集，a表示经过bitmap算法映射后的基于bit位的数组。 对于bitmap排序算法（包括bitmap映射和遍历排序两个步骤），其时间和空间复杂度取决于数据集中的最大值MAX。对于数据规模为n的整型数据集，如果采用int型数组表示bitmap信息，即每32bit为一个单元，则其时间复杂度为O(max(n, MAX/32)), 如果在遍历排序阶段开m个线程读，那么其时间复杂度为O(max(n, (MAX/32)/m)); 空间复杂度为O(max(n, MAX/32))。 优点与缺点 优点 (1). 运算效率高，不进行数据比较；查找，去重存储效率高，不需要遍历全部数据就可以进行。 (2). 占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。 (3). 在数据量大且重复率少的情况下，可以极大程度的压缩存储空间，并且保证有序。 (4). 对于特定的，只有0，1特征值，并且含有唯一识别号的数据存储中，优势巨大，节省存储空间，查询和维护的成本。 缺点 (1). 所有的数据不能重复，即不可对重复的数据进行排序。（针对少量重复的数据，假设其重复次数为n，则 a = {n的平方根 + 1} 表示, 可以用a-bitmap算法。比如当a=5时，则利用3-bitmap算法）。 (2). 当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。 应用示例适用场景Bitmap算法适用于： 可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下； 去重数据而达到压缩数据； 用于爬虫系统中url去重、解决全组合问题； Bitmap算法可以扩展为Bloom filter(布隆过滤器)。 问题 1：在2.5亿个整数中找出不重复的整数，约束条件时内存不足以容纳这2.5亿个整数。解法一：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 解法二：也可采用进行划分小文件的方法，然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。” 问题 2：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？解法一：可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 问题 3：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。解法一：8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话） 问题 4：给定一个数组a，求所有和为SUM的两个数。解法一：如果数组都是整数（负数也可以，将所有数据加上最小的负数x，SUM += 2x就可以了）。如a = [1,2,3,4,7,8]，先求a的补数组[8,7,6,5,2,1]，开辟两个数组b1,b2（最大数组长度为SUM/8/2{因为两数满足和为SUM，一个数&lt;SUM/2，另一个数也就知道了}，这样每个b数组最大内存为SUM/(821024*1024) = 128M）,使用bitmap算法和数组a分别设置b1、b2对应的位为1，b1、b2相与就可以得到和为SUM的两个数其中一个数了。 参考文献 Bitmap 方法 BigMap 算法 Bloom Filter 布隆过滤器","categories":[{"name":"每周技术分享","slug":"每周技术分享","permalink":"http://yoursite.com/categories/每周技术分享/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://yoursite.com/tags/Bitmap/"},{"name":"Sort","slug":"Sort","permalink":"http://yoursite.com/tags/Sort/"}],"keywords":[{"name":"每周技术分享","slug":"每周技术分享","permalink":"http://yoursite.com/categories/每周技术分享/"}]},{"title":"RDMA-Driven Paxos Consistent Algorithm","slug":"RDMA-Driven-Paxos-Consistent-Algorithm","date":"2018-10-15T04:24:53.000Z","updated":"2018-10-15T22:25:26.233Z","comments":true,"path":"2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/","link":"","permalink":"http://yoursite.com/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/","excerpt":"","text":"下周即将分享，敬请期待。","categories":[{"name":"每周技术分享","slug":"每周技术分享","permalink":"http://yoursite.com/categories/每周技术分享/"}],"tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://yoursite.com/tags/RDMA/"},{"name":"Paxos","slug":"Paxos","permalink":"http://yoursite.com/tags/Paxos/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"每周技术分享","slug":"每周技术分享","permalink":"http://yoursite.com/categories/每周技术分享/"}]},{"title":"Google Protocol Buffer 实践","slug":"Google-Protocol-Buffer-实践","date":"2018-09-17T23:16:54.000Z","updated":"2018-10-15T23:51:28.475Z","comments":true,"path":"2018/09/18/Google-Protocol-Buffer-实践/","link":"","permalink":"http://yoursite.com/2018/09/18/Google-Protocol-Buffer-实践/","excerpt":"","text":"简介 什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。 Google Protocol Buffer Demo安装Google Protocol Buffer在网站 http://code.google.com/p/protobuf/downloads/list上可以下载 Protobuf 的源代码。然后解压编译安装便可以使用它了。安装步骤如下所示：123456tar -xzf protobuf-2.1.0.tar.gzcd protobuf-2.1.0./configure --prefix=$INSTALL_DIRmakemake checkmake install Demo描述我打算使用 Protobuf 和 C++ 开发一个十分简单的例子程序。该程序由两部分组成。第一部分被称为 Writer，第二部分叫做 Reader。Writer 负责将一些结构化的数据写入一个磁盘文件，Reader 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。准备用于演示的结构化数据是 HelloWorld，它包含两个基本数据： ID，为一个整数类型的数据 Str，这是一个字符串 创建编写.proto 文件首先我们需要编写一个 proto 文件，定义我们程序中需要处理的结构化数据，在 protobuf 的术语中，结构化数据被称为 Message。proto 文件非常类似 java 或者 C 语言的数据定义。代码清单 1 显示了例子应用中的 proto 文件内容。 清单1. lm.helloworld.proto12345678// lm.helloworld.protopackage lm;message helloworld&#123; required int32 id = 1; // ID required string str = 2; // str optional int32 opt = 3; //optional field&#125; 一个比较好的习惯是认真对待 proto 文件的文件名。比如将命名规则定于如下： 1packageName.MessageName.proto 在上例中，package 名字叫做 lm，定义了一个消息 helloworld，该消息有三个成员，类型为 int32 的 id，另一个为类型为 string 的成员 str。opt 是一个可选的成员，即消息中可以不包含该成员。 编译 .proto 文件写好 proto 文件之后就可以用 Protobuf 编译器将该文件编译成目标语言了。本例中我们将使用 C++。假设您的 proto 文件存放在 $SRC_DIR 下面，您也想把生成的文件放在同一个目录下，则可以使用如下命令： 1protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto 命令将生成两个文件： lm.helloworld.pb.h ， 定义了 C++ 类的头文件 lm.helloworld.pb.cc ， C++ 类的实现文件 在生成的头文件中，定义了一个 C++ 类 helloworld，后面的 Writer 和 Reader 将使用这个类来对消息进行操作。诸如对消息的成员进行赋值，将消息序列化等等都有相应的方法。 编写 writer 和 Reader如前所述，Writer 将把一个结构化数据写入磁盘，以便其他人来读取。假如我们不使用 Protobuf，其实也有许多的选择。一个可能的方法是将数据转换为字符串，然后将字符串写入磁盘。转换为字符串的方法可以使用 sprintf()，这非常简单。数字 123 可以变成字符串”123”。这样做似乎没有什么不妥，但是仔细考虑一下就会发现，这样的做法对写 Reader 的那个人的要求比较高，Reader 的作者必须了 Writer 的细节。比如”123”可以是单个数字 123，但也可以是三个数字 1,2 和 3，等等。这么说来，我们还必须让 Writer 定义一种分隔符一样的字符，以便 Reader 可以正确读取。但分隔符也许还会引起其他的什么问题。最后我们发现一个简单的 Helloworld 也需要写许多处理消息格式的代码。 如果使用 Protobuf，那么这些细节就可以不需要应用程序来考虑了。使用 Protobuf，Writer 的工作很简单，需要处理的结构化数据由 .proto 文件描述，经过上一节中的编译过程后，该数据化结构对应了一个 C++ 的类，并定义在 lm.helloworld.pb.h 中。对于本例，类名为 lm::helloworld。Writer 需要 include 该头文件，然后便可以使用这个类了。现在，在 Writer 代码中，将要存入磁盘的结构化数据由一个 lm::helloworld 类的对象表示，它提供了一系列的 get/set 函数用来修改和读取结构化数据中的数据成员，或者叫 field。当我们需要将该结构化数据保存到磁盘上时，类 lm::helloworld 已经提供相应的方法来把一个复杂的数据变成一个字节序列，我们可以将这个字节序列写入磁盘。对于想要读取这个数据的程序来说，也只需要使用类 lm::helloworld 的相应反序列化方法来将这个字节序列重新转换会结构化数据。这同我们开始时那个“123”的想法类似，不过 Protobuf 想的远远比我们那个粗糙的字符串转换要全面，因此，我们不如放心将这类事情交给 Protobuf 吧。代码清单2列出了Writer的核心代码。 清单2. Writer.cpp代码123456789101112131415161718#include \"lm.helloworld.pb.h\"… int main(void) &#123; lm::helloworld msg1; msg1.set_id(101); msg1.set_str(“hello”); // Write the new address book back to disk. fstream output(\"./log\", ios::out | ios::trunc | ios::binary); if (!msg1.SerializeToOstream(&amp;output)) &#123; cerr &lt;&lt; \"Failed to write msg.\" &lt;&lt; endl; return -1; &#125; return 0; &#125; 其中，Msg1 是一个 helloworld 类的对象，set_id() 用来设置 id 的值。SerializeToOstream 将对象序列化后写入一个 fstream 流。 代码清单 3 列出了 reader 的主要代码。清单2. Reader.cpp代码12345678910111213141516171819202122#include \"lm.helloworld.pb.h\"… void ListMsg(const lm::helloworld &amp; msg) &#123; cout &lt;&lt; msg.id() &lt;&lt; endl; cout &lt;&lt; msg.str() &lt;&lt; endl; &#125; int main(int argc, char* argv[])&#123; lm::helloworld msg1; &#123; fstream input(\"./log\", ios::in | ios::binary); if (!msg1.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; \"Failed to parse address book.\" &lt;&lt; endl; return -1; &#125; &#125; ListMsg(msg1); … &#125; 同样，Reader 声明类 helloworld 的对象 msg1，然后利用 ParseFromIstream 从一个 fstream 流中读取信息并反序列化。此后，ListMsg 中采用 get 方法读取消息的内部信息，并进行打印输出操作。 运行结果运行 Writer 和 Reader 的结果如下：1234&gt;writer&gt;reader101Hello Reader 读取文件 log 中的序列化信息并打印到屏幕上。 这个例子本身并无意义，但只要您稍加修改就可以将它变成更加有用的程序。比如将磁盘替换为网络 socket，那么就可以实现基于网络的数据交换任务。而存储和交换正是 Protobuf 最有效的应用领域。 和其他类似技术的比较看完这个简单的例子之后，希望您已经能理解 Protobuf 能做什么了，那么您可能会说，世上还有很多其他的类似技术啊，比如 XML，JSON，Thrift 等等。和他们相比，Protobuf 有什么不同呢？ 简单说来 Protobuf 的主要优点就是：简单，快。这有测试为证，项目 thrift-protobuf-compare 比较了这些类似的技术，图 1 显示了该项目的一项测试结果，Total Time. Total Time 指一个对象操作的整个时间，包括创建对象，将对象序列化为内存中的字节序列，然后再反序列化的整个过程。从测试结果可以看到 Protobuf 的成绩很好，感兴趣的读者可以自行到网站 [https://github.com/eishay/jvm-serializers/wiki)上了解更详细的测试结果。 Protobuf 的优点 Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。 它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。 Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。 使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。 Protobuf 的不足 Protbuf 与 XML 相比也有不足之处。它功能简单，无法用来表示复杂的概念。 XML 已经成为多种行业标准的编写工具，Protobuf 只是 Google 公司内部使用的工具，在通用性上还差很多。 由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。 高级应用话题更复杂的 Message到这里为止，我们只给出了一个简单的没有任何用处的例子。在实际应用中，人们往往需要定义更加复杂的 Message。我们用“复杂”这个词，不仅仅是指从个数上说有更多的 fields 或者更多类型的 fields，而是指更加复杂的数据结构： 嵌套 Message 代码清单 4 给出一个嵌套 Message 的例子。 清单 4. 嵌套 Message 的例子1234567891011121314151617message Person &#123; required string name = 1; required int32 id = 2; // Unique ID number for this person. optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phone = 4;&#125; 在 Message Person 中，定义了嵌套消息 PhoneNumber，并用来定义 Person 消息中的 phone 域。这使得人们可以定义更加复杂的数据结构。 Import Message 在一个 .proto 文件中，还可以用 Import 关键字引入在其他 .proto 文件中定义的消息，这可以称做 Import Message，或者 Dependency Message。例子如下所示：清单 5. Import Message 123456import common.header;message youMsg&#123; required common.info_header header = 1; required string youPrivateData = 2;&#125; 其中 ,common.info_header定义在common.header包内。 Import Message 的用处主要在于提供了方便的代码管理机制，类似 C 语言中的头文件。您可以将一些公用的 Message 定义在一个 package 中，然后在别的 .proto 文件中引入该 package，进而使用其中的消息定义。Google Protocol Buffer 可以很好地支持嵌套 Message 和引入 Message，从而让定义复杂的数据结构的工作变得非常轻松愉快。 动态编译一般情况下，使用 Protobuf 的人们都会先写好 .proto 文件，再用 Protobuf 编译器生成目标语言所需要的源代码文件。将这些生成的代码和应用程序一起编译。 可是在某且情况下，人们无法预先知道 .proto 文件，他们需要动态处理一些未知的 .proto 文件。比如一个通用的消息转发中间件，它不可能预知需要处理怎样的消息。这需要动态编译 .proto 文件，并使用其中的 Message。 Protobuf 提供了 google::protobuf::compiler 包来完成动态编译的功能。主要的类叫做 importer，定义在 importer.h 中。使用 Importer 非常简单，下图展示了与 Import 和其它几个重要的类的关系。 首先构造一个 importer 对象。构造函数需要两个入口参数，一个是 source Tree 对象，该对象指定了存放 .proto 文件的源目录。第二个参数是一个 error collector 对象，该对象有一个 AddError 方法，用来处理解析 .proto 文件时遇到的语法错误。之后，需要动态编译一个 .proto 文件时，只需调用 importer 对象的 import 方法。非常简单。 那么我们如何使用动态编译后的 Message 呢？我们需要首先了解几个其他的类。Package google::protobuf::compiler 中提供了以下几个类，用来表示一个 .proto 文件中定义的 message，以及 Message 中的 field，如图3所示。 类 FileDescriptor 表示一个编译后的 .proto 文件；类 Descriptor 对应该文件中的一个 Message；类 FieldDescriptor 描述一个 Message 中的一个具体 Field。 比如编译完 lm.helloworld.proto 之后，可以通过如下代码得到 lm.helloworld.id 的定义： 清单 7. 得到 lm.helloworld.id 的定义的代码1234const protobuf::Descriptor *desc = importer_.pool()-&gt;FindMessageTypeByName(“lm.helloworld”);const protobuf::FieldDescriptor* field = desc-&gt;pool()-&gt;FindFileByName (“id”); 通过 Descriptor，FieldDescriptor 的各种方法和属性，应用程序可以获得各种关于 Message 定义的信息。比如通过 field-&gt;name() 得到 field 的名字。这样，您就可以使用一个动态定义的消息了。 编写新的 proto 编译器随 Google Protocol Buffer 源代码一起发布的编译器 protoc 支持 3 种编程语言：C++，java 和 Python。但使用 Google Protocol Buffer 的 Compiler 包，您可以开发出支持其他语言的新的编译器。 类 CommandLineInterface 封装了 protoc 编译器的前端，包括命令行参数的解析，proto 文件的编译等功能。您所需要做的是实现类 CodeGenerator 的派生类，实现诸如代码生成等后端工作： 程序的大体框架如图所示： 在 main() 函数内，生成 CommandLineInterface 的对象 cli，调用其 RegisterGenerator() 方法将新语言的后端代码生成器 yourG 对象注册给 cli 对象。然后调用 cli 的 Run() 方法即可。 这样生成的编译器和 protoc 的使用方法相同，接受同样的命令行参数，cli 将对用户输入的 .proto 进行词法语法等分析工作，最终生成一个语法树。该树的结构如图所示。 其根节点为一个 FileDescriptor 对象（请参考“动态编译”一节），并作为输入参数被传入 yourG 的 Generator() 方法。在这个方法内，您可以遍历语法树，然后生成对应的您所需要的代码。简单说来，要想实现一个新的 compiler，您只需要写一个 main 函数，和一个实现了方法 Generator() 的派生类即可。","categories":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/categories/C-C-编程/"}],"tags":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/tags/C-C-编程/"}],"keywords":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/categories/C-C-编程/"}]},{"title":"C语言中snprintf()函数","slug":"C语言中snprintf-函数","date":"2018-06-07T23:24:28.000Z","updated":"2018-10-15T23:27:37.736Z","comments":true,"path":"2018/06/08/C语言中snprintf-函数/","link":"","permalink":"http://yoursite.com/2018/06/08/C语言中snprintf-函数/","excerpt":"","text":"函数原型：snprintf(char* dest_str,size_t size,const char* format,...);```12345678910111213141516171819202122232425262728293031- **函数功能**：先将可变参数 “...” 按照format的格式格式化为字符串，然后再将其拷贝至dest_str中。- **头文件**：#include&lt;stdio.h&gt;- **注意事项**： - 如果如果格式化后的字符串长度小于size，则将字符串全部拷贝至dest_str中，并在字符串结尾处加上‘\\0’； - 如果格式化后的字符串长度大于或等于size，则将字符串的(size-1)拷贝至dest_str中，然后在字符串结尾处加上&apos;\\0&apos;. - 函数返回值是 格式化字符串的长度。- **使用示例**：``` C#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; char test_str[4096]; memset(test_str, 0, sizeof(test_str)); char *str_1 = &quot;复旦大学&quot;; int size = strlen(str_1); char *name = &quot;Bob Huang&quot;; int year = 2018; int month = 6; int day = 8; snprintf(test_str, sizeof(test_str), &quot;学校:%s\\n名字:%s\\nToday:%d年%d月%d日\\n&quot;, str_1, name, year, month, day); printf(&quot;%s\\n&quot;, test_str); return 0;&#125; 运行结果：","categories":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/categories/C-C-编程/"}],"tags":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/tags/C-C-编程/"}],"keywords":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/categories/C-C-编程/"}]},{"title":"Makefile中.PHONY的使用","slug":"Makefile中-PHONY的使用","date":"2018-06-07T23:23:18.000Z","updated":"2018-10-15T23:41:14.470Z","comments":true,"path":"2018/06/08/Makefile中-PHONY的使用/","link":"","permalink":"http://yoursite.com/2018/06/08/Makefile中-PHONY的使用/","excerpt":"","text":"在C项目构建中，经常在Makefile文件中用到.PHONY配置项。.PHONY配置项的主要作用在于避免指定命令和项目下的同名文件冲突，进行性能优化。.PHONY [command name] 显式指定了一个命令名称【而不是实际文件名】，是为了避免该命令名称与makefile同路径下的文件名重名冲突，以使make [command name]命令可以正确被解析、执行。下面将举例说明。 例 1如果编写一个规则名称为clean，不产生目标文件，那么该命令在执行make clean时规则都会被执行，makefile内容如下：12clean: rm -f *.o temp rm 命令不产生任何clean文件。 如果目录下不存在名为”clean”的文件，则运行make clean时，命令都会正常执行； 如果目录下存在名为”clean”的文件，则运行make clean时，命令规则会失效，文件”clean”没有依赖文件，始终是最新的，make clean永远不会被执行。为了解决上述问题，可以使用.PHONY clean指明该clean命令。如下： 1234.PHONY cleanclean: rm -f *.o temp 这样执行命令make clean会自动忽略名为”clean”文件的存在。已知.PHONY配置项的目标并不是其他文件生成的实际文件，make命令会自动绕过隐含规则搜索过程，因此声明.PHONY配置项会改善性能，bi且不需要担心实际同名文件存在与否。 例 2如果.PHONY目标有依赖关系。当一个目录中存在多个可运行程序，将其配置在同一个makefile文件。由于make [command name/ Default command]默认缺省规则是makefile文件中的第一个规则，一般将这第一个规则称为“all”，其依赖文件为多个可运行程序，如下：12345678all: p1 p2 p3.PHONY: allp1: p1.o utils.o cc -o p1 p1.o utils.op2: p2.o utils.o cc -o p2 p2.o utils.op3: p3.o utils.o cc -o p3 p3.o utils.o 其中p1、p2和p3是三个可执行文件，make把“all”作为主要规则，每次执行时都尝试把”all”更新，因此会检查其依赖文件p1、p2和p3是否需要更新，如果需要，就把它们更新，从而达到我们的目的。通过.PHONY指定目标为all，可以避免目录下同名文件的干扰，即不用检查规则”all”是否有同名文件存在，也不需要查询任何隐含规则，直接假定指定的规则”all”需要被更新。 综上所述，.PHONY是一个伪目标，可以有效防止在Makefile文件中定义的可执行命令的目标规则和工作目录下的实际文件出现名称冲突，并提高了执行Makefile的性能。 Bob Huang2018.0608","categories":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/categories/C-C-编程/"}],"tags":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/tags/C-C-编程/"}],"keywords":[{"name":"C/C++编程","slug":"C-C-编程","permalink":"http://yoursite.com/categories/C-C-编程/"}]},{"title":"Web网站高并发量的解决方案","slug":"Web网站高并发量的解决方案","date":"2016-08-03T23:03:38.000Z","updated":"2018-10-15T23:15:44.702Z","comments":true,"path":"2016/08/04/Web网站高并发量的解决方案/","link":"","permalink":"http://yoursite.com/2016/08/04/Web网站高并发量的解决方案/","excerpt":"","text":"摘要： 一个小型的网站，可以使用最简单的html静态页面就实现了，配合一些图片达到美化效果，所有的页面均存放在一个目录下，这样的网站对系统架构、性能的要求都很简单。随着互联网业务的不断丰富，网站相关的技术经过这些年的发展，已经细分到很细的方方面面，尤其对于大型网站来说，所采用的技术更是涉及面非常广，从硬件到软件、编程语言、数据库、WebServer、防火墙等各个领域都有了很高的要求，已经不是原来简单的html静态网站所能比拟的。 大型网站，比如门户网站，在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。这几个解决思路在一定程度上意味着更大的投入。 HTML静态化 其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统CMS，像我们常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。 除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化、有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。 同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现。比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储在数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。 图片服务器分离 大家知道，对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的、甚至很多台的图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃。 在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持、尽可能少的LoadModule，保证更高的系统消耗和执行效率。 数据库集群、库表散列 大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表散列。 在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是类似的方案，您使用了什么样的DB，就参考相应的解决方案来实施即可。 上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用DB类型的限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并且最有效的解决方案。 我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。 sohu的论坛就是采用了这样的架构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板块和ID进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系统随时增加一台低成本的数据库进来补充系统性能。 缓存 缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。这里先讲述最基本的两种缓存。高级和分布式的缓存在后面讲述。 架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。 网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，.net不是很熟悉，相信也肯定有。 镜像 镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。 负载均衡 负载均衡将是大型网站解决高负荷访问和大量并发请求采用的高端解决办法。 负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择，我个人接触过一些解决方法，其中有两个架构可以给大家做参考。（1）、硬件四层交换 第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。 第四层交换功能就像是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、TCP和UDP端口共同决定。 在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。“Yahoo中国”当初接近2000台服务器，只使用了三、四台Alteon就搞定了。(2)、软件四层交换 大家知道了硬件四层交换机的原理后，基于OSI模型来实现的软件四层交换也就应运而生，这样的解决方案实现的原理一致，不过性能稍差。但是满足一定量的压力还是游刃有余的，有人说软件实现方式其实更灵活，处理能力完全看你配置的熟悉能力。 软件四层交换我们可以使用Linux上常用的LVS来解决，LVS就是Linux Virtual Server，他提供了基于心跳线heartbeat的实时灾难应对解决方案，提高系统的强壮性，同时可供了灵活的虚拟VIP配置和管理功能，可以同时满足多种应用需求，这对于分布式的系统来说必不可少。 一个典型的使用负载均衡的策略就是，在软件或者硬件四层交换的基础上搭建squid集群，这种思路在很多大型网站包括搜索引擎上被采用，这样的架构低成本、高性能还有很强的扩张性，随时往架构里面增减节点都非常容易。 对于大型网站来说，前面提到的每个方法可能都会被同时使用到，这里介绍得比较浅显，具体实现过程中很多细节还需要大家慢慢熟悉和体会。有时一个很小的squid参数或者apache参数设置，对于系统性能的影响就会很大。 最新：CDN加速技术 CDN的全称是内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。 CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。CDN的类型特点 CDN的实现分为三类：镜像、高速缓存、专线。 镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。 高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。 CDN服务一般会在全国范围内的关键节点上放置缓存服务器。 专线，让用户直接访问数据源，可以实现数据的动态同步。CDN的实例 举个例子来说，当某用户访问网站时，网站会利用全球负载均衡技术，将用户的访问指向到距离用户最近的正常工作的缓存服务器上，直接响应用户的请求。 当用户访问已经使用了CDN服务的网站时，其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地DNS的解析请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。 通过用户定位算法和服务器健康检测算法综合后的数据，可以将用户的请求就近定向到分布在网络“边缘”的缓存服务器上，保证用户的访问能得到更及时可靠的响应。 由于大量的用户访问都由分布在网络边缘的CDN节点缓存服务器直接响应了，这就不仅提高了用户的访问质量，同时有效地降低了源服务器的负载压力。 Bobo20160804","categories":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/categories/架构/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://yoursite.com/tags/程序猿/"},{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"http://yoursite.com/tags/JAVA-WEB/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/categories/架构/"}]},{"title":"提高程序员编程效率的好习惯","slug":"提高程序员编程效率的好习惯","date":"2016-08-03T22:56:52.000Z","updated":"2018-10-15T23:02:54.692Z","comments":true,"path":"2016/08/04/提高程序员编程效率的好习惯/","link":"","permalink":"http://yoursite.com/2016/08/04/提高程序员编程效率的好习惯/","excerpt":"","text":"只做需要做的工作使用敏捷方法； 全心全意做UX设计； 沟通第一； 编码也许不是解决问题的办法； 过早的优化是一切罪恶的根源； 选择最简单的解决方案。 站在巨人的肩膀上使用开源框架； 使用简洁语言； 不要做重复的事情（不要重新发明轮子）； 利用包管理器来进行公共和私有代码分配； 不要任凭巨头（如微软）的摆布而修复库中的一个Bug； 不要让你的雇主逼你学习； 自主学习并为自己设定新的目标。 了解数据结构和算法如果你不知道什么时候应该使用快速排序、不懂辨认O(n2)程序、不会写递归函数，你将无法成为10倍效率的开发者。使用多种语言你才能清楚不同的框架是如何解决相同问题的。尽可能去了解底层命令（plumbing），以便能够作出明智的决定（Web框架是怎么存储session状态的？Cookie到底是什么？）。 不要怕买工具，它可以节省你的时间Ben说：“昨天我花50美元买了一个位图字体工具，它帮我节省的时间成本绝对超过200美元。” 集中注意力不要整天开着你的电子邮件、Twitter、Facebook等，在工作时将它们最小化或关掉它们，戴上耳机。Tiny hack说：“即使不听音乐我也戴着耳机工作，这样便不会有人打扰到我。” 尽早并且经常性地进行代码重构有时，你不得不放弃漂亮的代码转而去寻找真正对项目有用的代码，但没关系，如果你的现有项目中有这样的代码，最好的方式便是不要看它，并重构。 只管去做将你的业余项目分享到Startup Weekend中。在我开始转到Unix和Ruby on Rails上之前，我买了一台Mac，使用Windows虚拟机花了一年时间做.NET项目。 挑选一个编辑器，并掌握它高效开发者喜欢用文本编辑器胜过IDE编辑器，因为这样可以学到更多东西。无论什么情况，尽量使用键盘快捷键，因为熟练使用一件工具的前提是熟悉它。 在选择编辑器时，认真考虑并挑选最好的（Emacs或Vim），因为它们是通用的。其次，挑选你的首选平台最支持的。使用宏，不断地写代码；使用Mac上的TextExpander为整个段落创建快捷方式；使用Visual Studio或SublimeText的自动补齐功能；使用支持按行/列分割窗口的编辑器，这样你便能同时看到单元测试和代码（或模型、视图）。 一定要想清楚后再写代码。Adam说，“我有朋友在一个大项目组里工作，他们组里最高效的程序员是一个高位截瘫用嘴叼着棍子敲代码的人，他总是在写代码之前想得很仔细且很少出错。” 整洁的代码胜过巧妙的代码要想让其他人能够读懂你的代码，尽量使用最少的代码来完成任务。遵循DRY（Don’t repeat yourself）的原则，使用明确定义的对象和库，将任务分解成小而简单的代码段。 潜意识是强大的工具离开10分钟往往就可以解决一个问题。控制编程时间，给自己一个多姿多彩的生活，劳逸结合能让你在工作时更高效、更愉悦。当然，即便是上了年纪的程序员也知道，以最少的时间完成最高效的工作是成为10倍效率开发者的必要条件。 作为一个程序员，我觉得在职业生涯中最好的一件事儿就是从电脑前站起来，去拜访那些在某一领域有所建树的人们。 推动自身和团队进步重视批评，以包容的态度接受批评并提升自己是非常重要的事情。没有这个基础，你不可能成为一个高效的开发者。一位智者曾经说过：“聪明的人善于从自己的错误中学习，而智慧的人善于从别人的错误中学习。” Bob20160804","categories":[{"name":"闲思碎语","slug":"闲思碎语","permalink":"http://yoursite.com/categories/闲思碎语/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://yoursite.com/tags/程序猿/"}],"keywords":[{"name":"闲思碎语","slug":"闲思碎语","permalink":"http://yoursite.com/categories/闲思碎语/"}]},{"title":"跨域资源共享CORS总结","slug":"跨域资源共享CORS总结","date":"2016-08-01T23:04:45.000Z","updated":"2018-10-15T23:53:07.404Z","comments":true,"path":"2016/08/02/跨域资源共享CORS总结/","link":"","permalink":"http://yoursite.com/2016/08/02/跨域资源共享CORS总结/","excerpt":"","text":"摘要：CORS是一个W3C标准，全程是“跨域资源共享”（Cross-origin resource sharing）。CORS允许浏览器向跨源服务器发出XMLHttpRequest请求，以克服AJAX只能基于同源策略的使用限制。本文将详细介绍CORS的内部机制。 简介&emsp;&emsp;CORS需要浏览器与服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。&emsp;&emsp;整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求（如添加了Origin : http://localhost:63343，Access-Control-Request-Headers : accept, content-type，Access-Control-Request-Method : POST），但是用户不会有感觉。&emsp;&emsp;因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口或者约定，就可以跨源通信。 两种请求&emsp;&emsp;浏览器把CORS请求分成：简单请求（Simple Request）和非简单请求（Not-so simple request）。&emsp;&emsp;只要同时满足一下两个条件，就属于简单请求。&emsp;&emsp;（1）请求方法是HEAD/GET/POST三种方法之一；&emsp;&emsp;（2）HTTP的头信息不超出一下几种字段：Accept/Accept-Encoding/Accept-Language/Cache-Control/Connection/Cookie/Host/If-Modified-Since/Referer/User-Agent/Content-Type/Content-Language。其中Content-Type仅限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/pain。&emsp;&emsp;凡是不满足上面两个条件，就属于非简单请求。浏览器对于两种请求的处理是不一样的。 简单请求基本流程&emsp;&emsp;对于简单请求，浏览器直接发出CORS请求，在HTTP HEADER中增加了Origin字段。如下：1234567891011POST /nlp/segment HTTP/1.1Host: 10.1.222.80:8084Connection: keep-aliveContent-Length: 90Accept: */*; q=0.01Origin: http://localhost:63343User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36Content-Type: application/ x-www-form-urlencoded;charset=UTF-8Referer: http://localhost:63343/BZZZ/bz.html?_ijt=eu8vkf2u50ccl1gshpr4lhjt3rAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8 &emsp;&emsp;上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，决定是否同意这次请求。如果Origin制定的源不在许可范围之内，服务器会返回一个正常的HTTP回应。浏览器发现Http Response头信息中没有包含Access-Control-Allow-Origin字段，就判断出错并抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200.&emsp;&emsp;如果Origin制定的域名在许可范围内，服务器返回的响应中多出几个头信息字段：12345Access-Control-Allow-Headers:Content-TypeAccess-Control-Allow-Methods:GET,POST,PUT,OPTIONS,DELETEAccess-Control-Expose-Headers: FooBarAccess-Control-Allow-Origin:*Content-Type:text/html; charset=UTF-8 &emsp;&emsp;上面的头信息中，有三个与CORS请求相关的字段，均以Access-Control-开头。（1）. Access-Control-Allow-Origin&emsp;&emsp;该字段是必须的，它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。（2）. Access-Control-Allow-Credentials&emsp;&emsp;该字段可选，它是一个Bool值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求中，设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值只能设为true，没有false取值，如果服务器不要浏览器发送Cookie，删除该字段即可。（3）. Access-Control-Allow-Methods&emsp;&emsp;该字段可选，如果允许跨域请求的方法是PUT/GET/POST/OPTIONS/DELETE等其中的一项或几项，就需要设置该字段的值为”PUT,GET,POST,OPTIONS”。（4）. Access-Control-Expose-Headers&emsp;&emsp;该字段可选，CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6哥基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers字段中指定。上面的例子制定，getResponseHeader(’FooBar’)可以返回FooBar字段的值。（5）. Access-Control-Allow-Headers&emsp;&emsp;该字段可选，CORS请求时，如果是自定义Http Request Header，就必须在该字段中指定对应的Header Name，如例子中自定义Header为’Test’，那么需要在服务器端制定该字段为’Test’。 withCredentials属性&emsp;&emsp;上面提到CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。1Access-Control-Allow-Credentials: true &emsp;&emsp;另外一方面，开发者必须在AJAX请求中打开withCredentials属性。如下：12var xhr = new XMLHttpRequest();xhr.withCredentials = true; &emsp;&emsp;否则，即使服务器同意发送Cookie，浏览器也不会发送。或者服务器要求设置Cookie，浏览器也不会处理。如果省略withCredentials字段设置，有些浏览器还是会一起发送Cookie。这时需要显示关闭withCredentials。xhr.withCredentials = false;&emsp;&emsp;需要注意的是，如果发送Cookie，Access-Control-Allow-Origin就不能设为”*”，必须制定明确的、与请求网页一直的域名。同时Cookie依然遵循同源侧策略，只有用服务器域名设置设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）发起请求的网页代码中document.cookie无法读取服务器域名下的Cookie。 非简单请求预检请求&emsp;&emsp;非简单请求是对服务器有特殊要求的请求，比如请求方法是PUT/DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式itongxin之前，增加爱一次HTTP查询请求，叫预检请求（preflight）。&emsp;&emsp;浏览器现询问服务器，当前网页所在的域名是否在服务器的许可名单中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JS脚本：12345678910111213var test1 = &#123;method:&quot;segment&quot;, format:&quot;json&quot;, message:[&quot;我是中国人！&quot;,&quot;欢迎来到中国&quot;]&#125;;$.ajax(&#123; url : &quot;http://10.1.222.80:8084/nlp/segment&quot;, type : &quot;post&quot;, dataType : &quot;json&quot;, contentType:&quot;application/json;charset=utf-8&quot;, data :JSON.stringify(test1), crossDomain: true, /*headers:&#123; &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot; &#125;,*/ timeout : 10000&#125;); &emsp;&emsp;上面的请求中是Content-Type为application/json的请求。浏览器认为这是一个非简单请求，自动向服务器发送一个预检请求，要求服务器确认可以这样请求。下面是预检请求的HTTP头信息：1234567891011OPTIONS /nlp/segment HTTP/1.1Host: 10.1.222.80:8084Connection: keep-aliveAccess-Control-Request-Method: POSTOrigin: http://localhost:63343User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36Access-Control-Request-Headers: accept, content-typeAccept: */*Referer: http://localhost:63343/BZZZ/bz.html?_ijt=eu8vkf2u50ccl1gshpr4lhjt3rAccept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8 &emsp;&emsp;预检请求使用的请求方法是OPTIONS，表示这个请求用来询问。头信息中关键字段是Origin，表示请求来自哪个源。除了Origin字段，预检请求的头信息还包括两个特殊字段：&emsp;&emsp;（1）. Access-Control-Request-Method&emsp;&emsp;该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，例子中是POST。&emsp;&emsp;（2）. Access-Control-Request-Headers&emsp;&emsp;该字段是都好分割的字符串，指定浏览器CORS请求会额外发送的头信息字段，上面的例子默认application/json对应的额外字段是”Content-Type”。 预检请求的回应Response&emsp;&emsp;服务器收到预检请求后，检查Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，并做出回应。如下：12345678910HTTP/1.1 200 OKContent-Type: text/html; charset=UTF-8Connection: closeTime-Used: 25msContent-Length-UnGzipped: 7Access-Control-Allow-Origin: *Access-Control-Allow-Methods: GET,POST,PUT,OPTIONS,DELETEAccess-Control-Allow-Headers: Content-TypeContent-Encoding: gzipContent-Length: 33 &emsp;&emsp;上面的Http Response中，关键是Access-Control-Allow-Origin字段，表示http://localhost:63343可以请求数据，该字段可以设为”*”，表示同意任意跨源请求。&emsp;&emsp;如果服务器否定了预检请求，会返回一个正常的HTTP Response，但是没有任何CORS相关的头信息字段。这时候浏览器认为i额服务器不同意预检请求，因此出发一个错误，被XMLHttpRequest对象的onerror毁掉函数捕获。控制台会打印出如下报错信息。12XMLHttpRequest cannot load http://localhost:63343.Origin http://localhost:63343 is not allowed by Access-Control-Allow-Origin. &emsp;&emsp;服务器响应的CORS其他相关字段如下：123Access-Control-Allow-Origin: *Access-Control-Allow-Methods: GET,POST,PUT,OPTIONS,DELETEAccess-Control-Allow-Headers: Content-Type &emsp;&emsp;（1）. Access-Control-Allow-Methods&emsp;&emsp;该字段是必需的，其取值是逗号分割的字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的哪个方法。这个是为了避免多次预检请求。&emsp;&emsp;（2）. Access-Control-Allow-Headers&emsp;&emsp;如果浏览器请求包括Access-Control-Allow-Headers字段，则该字段是必须的，其取值是一个逗号分割的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段。&emsp;&emsp;（3）. Access-Control-Allow-Credentials&emsp;&emsp;该字段与简单请求时字段含义相同。&emsp;&emsp;（4）. Access-Control-Max-Age&emsp;&emsp;该字段可选，用来制定本次预检请求的有效期，单位为秒。缓存于浏览器中，在有效期中，不需要发出另一条预检请求。 浏览器的正常请求和回应&emsp;&emsp;一旦服务器通过了预检请求，以后每次浏览器正常的CORS请求就都与简单请求一样，包括Origin字段信息。服务器的回应也会有Access-Control-Allow-Origin字段。 与JSONP比较&emsp;&emsp;CORS与Jsonp使用目的相同，但是Jsonp只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的有时在于支持老式浏览器，以及向不支持CORS的网站请求数据。 黄博博2016年8月2日","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"http://yoursite.com/tags/JAVA-WEB/"},{"name":"REST API","slug":"REST-API","permalink":"http://yoursite.com/tags/REST-API/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}