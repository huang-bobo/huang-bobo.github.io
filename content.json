{"meta":{"title":"Bobo Huang写字的地方","subtitle":null,"description":null,"author":"Bob Huang","url":"http://yoursite.com"},"pages":[{"title":"每周技术分享","date":"2018-10-15T07:23:00.000Z","updated":"2018-10-15T21:42:54.078Z","comments":true,"path":"TechShare/index.html","permalink":"http://yoursite.com/TechShare/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-10-15T05:49:56.000Z","updated":"2018-10-15T21:42:16.627Z","comments":true,"path":"About/index.html","permalink":"http://yoursite.com/About/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-10-15T06:04:27.000Z","updated":"2018-10-15T21:42:42.518Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Bitmap算法:一种基于bit位的数据排序、查重艺术","slug":"Bitmap算法-一种基于bit位的数据排序、查重艺术","date":"2018-10-15T21:23:09.000Z","updated":"2018-10-15T21:25:07.151Z","comments":true,"path":"2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/","link":"","permalink":"http://yoursite.com/2018/10/16/Bitmap算法-一种基于bit位的数据排序、查重艺术/","excerpt":"","text":"随着大数据规模的逐渐增长，在单机上的海量数据条目排序、查重、压缩是一项很有挑战性的工作。随之而来的许多硬件加速技术、算法被提出来，并在生产环境中落地实践，Bitmap就是其中一种被普遍应用的大数据排序、查重的算法，该算法巧妙利用了bit位来表示一个数值在一组数据集合中的状态（如某元素是否存在数据集合中），极大地压缩了数据处理（排序、查重）所需要的内存空间。本文将从算法概述、基本原理与实现、算法评估、应用场景与实例四个方面进行阐述。 算法概述Bitmap（位图算法），是一种基于bit的映射算法，即用一个bit位（或几个bit位）来标记某个元素对应的状态value，而key即是该元素，对应的value即是该元素key的状态（0表示key不存在，1表示key存在），当然也可以根据需要选择多个bit位表示，2个bit标识4种状态，3个bit标识8种状态，n个bit标识2^n种状态。 由此产生了Bitmap位图数据结构。该数据结构描述了一个有限定义域内的稠密集合，其中（1）每一个元素最多出现一次；（2）并且没有其他任何数据与该元素相关联。即使这些条件没有完全满足（例如，存在重复元素或额外的数据），也可以用有限定义域内的键作为一个表项更复杂的表格的索引。 由于采用bit位存储数据，对于海量数据的查重、排序问题，可以大大节省所需内存存储空间，Bitmap算法适用于解决数据集中的每个元素最多出现一次（或n次）并且没有其他任何数据与该元素相关联的问题。 基本原理与实现Bitmap算法基本原理一个整型数据，比如int a;,在内存中占用32bit，可以用对应的32bit位对应十进制的0-31个数，bitmap算法利用这种思想处理大量数据的排序和查询。 我们举个例子，现在有一个无序有界int数组int[] b = {5,2,11,3},至少需要占用内存4*4=16个字节，但是如果有10亿个这样的数，大概需要1000000000*4/(1024*1024*1024)=3.72GB左右，如果针对这样大量的数据进行查询排序，内存肯定要溢出崩溃的。 针对上面的问题，使用Bitmap算法就可以轻易解决，一个byte占用8个bit，如果用bit的位置索引表示数组b中的元素值，bit位的取值（0或1）表示该元素在数组中的状态（是否存在），0表示不存在，1表示存在。那么整个过程如下所示： 申请一个int型（根据需要也可以申请long型或short型）的内存空间，则有4个Byte，共32bit。然后根据数组下标int[] b = {5,2,11,3}依次遍历5,2,11,3， 把相应的bit位置为1，表示该元素存在。其中，bit区域从低bit位到高bit位，对应的位置索引i即代表要标识的数组int[] b中元素值，bit位为1表示该元素存在数组中，默认为0表示元素不存在： 输入5，将相应的第 6 bit置为1： 输入2，将相应的第 3 bit置为1: 输入11，将相应的第 12 bit置为1: 输入3，将相应的第 4 bit置为1: Bitmap算法的基本原理很简单巧妙，关键是十进制和二进制bit之间的转换需要一个映射表，一方面在数据组装初始化时，需要将10进制数据映射到相应的bit位上；另一方面，在遍历一片bit区域时，需要将bit位信息解析为10进制数据及状态（有或无）。 Map映射表假设需要排序或者查重的整型数的总数N=10000000=10^7, 那么我们需要申请内存空间的大小为int a[1 + N/32](或者long long a[1 + N/64]),其中a[0]在内存中占用32bit，依次类推bitmap表如下： 12345678a[0] --------&gt; 0 ~ 31a[1] --------&gt; 32 ~ 63a[2] --------&gt; 64 ~ 95a[3] --------&gt; 96 ~ 127......a[312500] --------&gt; (10^7) ~ (10^7 + 31)......a[N/32] --------&gt; (N/32)*32 ~ ((N/32) * 32 + 31) Bit位移转换为了得到Map映射表，我们需要利用bit位移将10进制数转换位2进制bit位。 求十进制数 0 - n 对应的在数组 a 中的下标： index_loc = n / 32，32表示int型占用的32bit，index_loc即为n对应的数组下标。例如n = 80 , 则index_loc = 80 / 32 = 2, 因此n = 80在a[2]中。 求十进制数 0 - n 对应的bit位: bit_loc = N % 32，例如 n = 80, bit_loc = 80 % 32 = 16。 利用移位运算 0 - 31 使得a[index_loc]对应的32bit位为1. Bitmap算法实现（C语言）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SHIFT 5#define MASK 0x1F/** * 设置所在的bit位为1 * * T = O(1) * */void set(int n, int *arr)&#123; int index_loc, bit_loc; index_loc = n &gt;&gt; SHIFT; // 等价于n / 32 bit_loc = n &amp; MASK; // 等价于n % 32 。 h%2^n = h &amp; (2^n -1) arr[index_loc] |= 1 &lt;&lt; bit_loc;&#125;// 上述set函数等价于//void set(int i)//&#123;// a[i/32] |= (1&lt;&lt;(i%32));//&#125;/** * 初始化arr[index_loc]所有bit位为0 * * T = O(1) * */void clr(int n, int *arr)&#123; int index_loc; index_loc = n &gt;&gt; SHIFT; arr[index_loc] &amp;= 0;&#125;/** * 测试n所在的bit位是否为1 * * T = O(1) * */int test(int n, int *arr)&#123; int i, flag; i = 1 &lt;&lt; (n &amp; MASK); flag = arr[n &gt;&gt; SHIFT] &amp; i; return flag;&#125;int main(void)&#123; int i, num, space, *arr; while (scanf(\"%d\", &amp;num) != EOF) &#123; // 确定大小&amp;&amp;动态申请数组 space = num / 32 + 1; arr = (int *)malloc(sizeof(int) * space); // 初始化bit位为0 for (i = 0; i &lt;= num; i ++) clr(i, arr); // 设置num的比特位为1 set(num, arr); // 测试 if (test(num, arr)) &#123; printf(\"成功！\\n\"); &#125; else &#123; printf(\"失败!\\n\"); &#125; &#125; return 0;&#125; 以下将对上述代码进行解析： i&gt;&gt;SHIFT(相当于整除运算i/32，保留商) 其中SHIFT = 5，即i右移5bit，2^5=32,相当于i/32，即求出十进制i对应在数组a中的下标index_loc。比如i=20，通过i&gt;&gt;SHIFT=20&gt;&gt;5=0 可求得i=20的下标为0； i &amp; MASK (相当于取模运算i%32，保留余数) 其中MASK=0X1F,十六进制转化为十进制为31，二进制为0001 1111，i &amp;（0001 1111）相当于保留i的后5位。 比如i=23，二进制为：0001 0111，那么 0001 0111 &amp; 0001 1111 = 0001 0111 十进制为：23; 比如i=83，二进制为：0000 0000 0101 0011，那么 `0000 0000 0101 0011 &amp; 0000 0000 0001 0000 = 0000 0000 0001 1111` 十进制为：19 . 1&lt;&lt;(i &amp; MASK) 相当于把1左移 (i &amp; MASK)位, 比如(i &amp; MASK)=20，那么i&lt;&lt;20就相当于： `0000 0000 0000 0000 0000 0000 0000 0001 &gt;&gt;20 =0000 0000 0000 1000 0000 0000 0000 0000 ` - 算法评估复杂度分析 对于数据规模为n的整型数据集，Bitmap算法的时间复杂度为O(n), 空间复杂度为O(1)。 其中，存储bit位信息的数组a大小由最大数max决定。即size_of(a) = max_of(b), 其中b表示原始数据集，a表示经过bitmap算法映射后的基于bit位的数组。 对于bitmap排序算法（包括bitmap映射和遍历排序两个步骤），其时间和空间复杂度取决于数据集中的最大值MAX。对于数据规模为n的整型数据集，如果采用int型数组表示bitmap信息，即每32bit为一个单元，则其时间复杂度为O(max(n, MAX/32)), 如果在遍历排序阶段开m个线程读，那么其时间复杂度为O(max(n, (MAX/32)/m)); 空间复杂度为O(max(n, MAX/32))。 优点与缺点 优点 (1). 运算效率高，不进行数据比较；查找，去重存储效率高，不需要遍历全部数据就可以进行。 (2). 占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。 (3). 在数据量大且重复率少的情况下，可以极大程度的压缩存储空间，并且保证有序。 (4). 对于特定的，只有0，1特征值，并且含有唯一识别号的数据存储中，优势巨大，节省存储空间，查询和维护的成本。 缺点 (1). 所有的数据不能重复，即不可对重复的数据进行排序。（针对少量重复的数据，假设其重复次数为n，则 a = {n的平方根 + 1} 表示, 可以用a-bitmap算法。比如当a=5时，则利用3-bitmap算法）。 (2). 当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。 应用示例适用场景Bitmap算法适用于： 可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下； 去重数据而达到压缩数据； 用于爬虫系统中url去重、解决全组合问题； Bitmap算法可以扩展为Bloom filter(布隆过滤器)。 问题 1：在2.5亿个整数中找出不重复的整数，约束条件时内存不足以容纳这2.5亿个整数。解法一：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 解法二：也可采用进行划分小文件的方法，然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。” 问题 2：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？解法一：可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 问题 3：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。解法一：8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话） 问题 4：给定一个数组a，求所有和为SUM的两个数。解法一：如果数组都是整数（负数也可以，将所有数据加上最小的负数x，SUM += 2x就可以了）。如a = [1,2,3,4,7,8]，先求a的补数组[8,7,6,5,2,1]，开辟两个数组b1,b2（最大数组长度为SUM/8/2{因为两数满足和为SUM，一个数&lt;SUM/2，另一个数也就知道了}，这样每个b数组最大内存为SUM/(821024*1024) = 128M）,使用bitmap算法和数组a分别设置b1、b2对应的位为1，b1、b2相与就可以得到和为SUM的两个数其中一个数了。 参考文献 Bitmap 方法 BigMap 算法 Bloom Filter 布隆过滤器","categories":[{"name":"TechShare","slug":"TechShare","permalink":"http://yoursite.com/categories/TechShare/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"Bitmap","slug":"Bitmap","permalink":"http://yoursite.com/tags/Bitmap/"},{"name":"Sort","slug":"Sort","permalink":"http://yoursite.com/tags/Sort/"}],"keywords":[{"name":"TechShare","slug":"TechShare","permalink":"http://yoursite.com/categories/TechShare/"}]},{"title":"RDMA-Driven Paxos Consistent Algorithm","slug":"RDMA-Driven-Paxos-Consistent-Algorithm","date":"2018-10-15T04:24:53.000Z","updated":"2018-10-15T21:45:36.127Z","comments":true,"path":"2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/","link":"","permalink":"http://yoursite.com/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/","excerpt":"","text":"下周即将分享，敬请期待。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"RDMA","slug":"RDMA","permalink":"http://yoursite.com/tags/RDMA/"},{"name":"Paxos","slug":"Paxos","permalink":"http://yoursite.com/tags/Paxos/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}],"keywords":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}]}]}