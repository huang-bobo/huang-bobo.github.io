<!DOCTYPE HTML><html lang=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Bobo Huang写字的地方"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><link rel="dns-prefetch" href="http://yoursite.com"><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><title>Google Protocol Buffer 实践 | Bobo Huang写字的地方</title><link rel="alternate" href="/atom.xml" title="Bobo Huang写字的地方" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=58b7707886bb199811bed37162c7a60a"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css?rev=8f18d7189b91ee2c0129163e3c179bf3"><div class="hide"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"))</script></div></head><!--[if lte IE 8]><style>
    html{ font-size: 1em }
</style><![endif]--><!--[if lte IE 9]><div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div><![endif]--><body><header class="main-header" style="background-image:url(/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Bob Huang"><img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>从未如此简单有趣～</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span><i class="fa fa-bars"></i></span> <a class="navbar-brand" href="http://yoursite.com">Bobo Huang写字的地方</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa fa-home"></i> Home</a></li><li role="presentation" class="text-center"><a href="/tags/算法/"><i class="fa fa-tasks"></i> 算法</a></li><li role="presentation" class="text-center"><a href="/categories/闲思碎语/"><i class="fa fa-tags"></i> 闲思碎语</a></li><li role="presentation" class="text-center"><a href="/categories/每周技术分享/"><i class="fa fa-share"></i> 每周技术分享</a></li><li role="presentation" class="text-center"><a href="/About"><i class="fa fa-user"></i> About Me</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="Google Protocol Buffer 实践">Google Protocol Buffer 实践</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a href="/categories/C/C++编程">C/C++编程</a></span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a href="/tags/C/C++编程" title="C/C++编程">C/C++编程</a></span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2018/09/18</span></span></div></div><div class="post-body post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：<br>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<br>或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。</p></blockquote><h2 id="Google-Protocol-Buffer-Demo"><a href="#Google-Protocol-Buffer-Demo" class="headerlink" title="Google Protocol Buffer Demo"></a>Google Protocol Buffer Demo</h2><h4 id="安装Google-Protocol-Buffer"><a href="#安装Google-Protocol-Buffer" class="headerlink" title="安装Google Protocol Buffer"></a>安装Google Protocol Buffer</h4><p>在网站 <a href="http://code.google.com/p/protobuf/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/protobuf/downloads/list</a>上可以下载 Protobuf 的源代码。然后解压编译安装便可以使用它了。<br>安装步骤如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf protobuf-2.1.0.tar.gz</span><br><span class="line">cd protobuf-2.1.0</span><br><span class="line">./configure --prefix=$INSTALL_DIR</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p></p><h4 id="Demo描述"><a href="#Demo描述" class="headerlink" title="Demo描述"></a>Demo描述</h4><p>我打算使用 Protobuf 和 C++ 开发一个十分简单的例子程序。<br>该程序由两部分组成。第一部分被称为 Writer，第二部分叫做 Reader。<br>Writer 负责将一些结构化的数据写入一个磁盘文件，Reader 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。<br>准备用于演示的结构化数据是 HelloWorld，它包含两个基本数据：</p><ul><li>ID，为一个整数类型的数据</li><li>Str，这是一个字符串</li></ul><h4 id="创建编写-proto-文件"><a href="#创建编写-proto-文件" class="headerlink" title="创建编写.proto 文件"></a>创建编写.proto 文件</h4><p>首先我们需要编写一个 proto 文件，定义我们程序中需要处理的结构化数据，在 protobuf 的术语中，结构化数据被称为 Message。proto 文件非常类似 java 或者 C 语言的数据定义。代码清单 1 显示了例子应用中的 proto 文件内容。</p><p><strong>清单1. lm.helloworld.proto</strong><br></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// lm.helloworld.proto</span><br><span class="line">package lm;</span><br><span class="line">message helloworld</span><br><span class="line">&#123;</span><br><span class="line">   required int32     id = 1;  // ID</span><br><span class="line">   required string    str = 2;  // str</span><br><span class="line">   optional int32     opt = 3;  //optional field</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一个比较好的习惯是认真对待 proto 文件的文件名。比如将命名规则定于如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packageName.MessageName.proto</span><br></pre></td></tr></table></figure><p>在上例中，package 名字叫做 lm，定义了一个消息 helloworld，该消息有三个成员，类型为 int32 的 id，另一个为类型为 string 的成员 str。opt 是一个可选的成员，即消息中可以不包含该成员。</p><h4 id="编译-proto-文件"><a href="#编译-proto-文件" class="headerlink" title="编译 .proto 文件"></a>编译 .proto 文件</h4><p>写好 proto 文件之后就可以用 Protobuf 编译器将该文件编译成目标语言了。本例中我们将使用 C++。<br>假设您的 proto 文件存放在 $SRC_DIR 下面，您也想把生成的文件放在同一个目录下，则可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto</span><br></pre></td></tr></table></figure><p>命令将生成两个文件：</p><ul><li>lm.helloworld.pb.h ， 定义了 C++ 类的头文件</li><li>lm.helloworld.pb.cc ， C++ 类的实现文件</li></ul><p>在生成的头文件中，定义了一个 C++ 类 helloworld，后面的 Writer 和 Reader 将使用这个类来对消息进行操作。诸如对消息的成员进行赋值，将消息序列化等等都有相应的方法。</p><h4 id="编写-writer-和-Reader"><a href="#编写-writer-和-Reader" class="headerlink" title="编写 writer 和 Reader"></a>编写 writer 和 Reader</h4><p>如前所述，Writer 将把一个结构化数据写入磁盘，以便其他人来读取。假如我们不使用 Protobuf，其实也有许多的选择。一个可能的方法是将数据转换为字符串，然后将字符串写入磁盘。转换为字符串的方法可以使用 sprintf()，这非常简单。数字 123 可以变成字符串”123”。<br>这样做似乎没有什么不妥，但是仔细考虑一下就会发现，这样的做法对写 Reader 的那个人的要求比较高，Reader 的作者必须了 Writer 的细节。比如”123”可以是单个数字 123，但也可以是三个数字 1,2 和 3，等等。这么说来，我们还必须让 Writer 定义一种分隔符一样的字符，以便 Reader 可以正确读取。但分隔符也许还会引起其他的什么问题。最后我们发现一个简单的 Helloworld 也需要写许多处理消息格式的代码。</p><p><strong>如果使用 Protobuf，那么这些细节就可以不需要应用程序来考虑了。</strong><br>使用 Protobuf，Writer 的工作很简单，需要处理的结构化数据由 .proto 文件描述，经过上一节中的编译过程后，该数据化结构对应了一个 C++ 的类，并定义在 lm.helloworld.pb.h 中。对于本例，类名为 lm::helloworld。<br>Writer 需要 include 该头文件，然后便可以使用这个类了。<br>现在，在 Writer 代码中，将要存入磁盘的结构化数据由一个 lm::helloworld 类的对象表示，它提供了一系列的 get/set 函数用来修改和读取结构化数据中的数据成员，或者叫 field。<br>当我们需要将该结构化数据保存到磁盘上时，类 lm::helloworld 已经提供相应的方法来把一个复杂的数据变成一个字节序列，我们可以将这个字节序列写入磁盘。<br>对于想要读取这个数据的程序来说，也只需要使用类 lm::helloworld 的相应反序列化方法来将这个字节序列重新转换会结构化数据。这同我们开始时那个“123”的想法类似，不过 Protobuf 想的远远比我们那个粗糙的字符串转换要全面，因此，我们不如放心将这类事情交给 Protobuf 吧。代码清单2列出了Writer的核心代码。</p><p><strong>清单2. Writer.cpp代码</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lm.helloworld.pb.h"</span></span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  lm::helloworld msg1;</span><br><span class="line">  msg1.set_id(<span class="number">101</span>);</span><br><span class="line">  msg1.set_str(“hello”);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">  <span class="function">fstream <span class="title">output</span><span class="params">(<span class="string">"./log"</span>, ios::out | ios::trunc | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!msg1.SerializeToOstream(&amp;output)) &#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write msg."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>其中，Msg1 是一个 helloworld 类的对象，set_id() 用来设置 id 的值。SerializeToOstream 将对象序列化后写入一个 fstream 流。</p><p>代码清单 3 列出了 reader 的主要代码。<br><strong>清单2. Reader.cpp代码</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lm.helloworld.pb.h"</span></span></span><br><span class="line">…</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ListMsg</span><span class="params">(<span class="keyword">const</span> lm::helloworld &amp; msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lm::helloworld msg1;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(<span class="string">"./log"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!msg1.ParseFromIstream(&amp;input)) &#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse address book."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListMsg(msg1);</span><br><span class="line">  …</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>同样，Reader 声明类 helloworld 的对象 msg1，然后利用 ParseFromIstream 从一个 fstream 流中读取信息并反序列化。此后，ListMsg 中采用 get 方法读取消息的内部信息，并进行打印输出操作。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>运行 Writer 和 Reader 的结果如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;writer</span><br><span class="line">&gt;reader</span><br><span class="line">101</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p></p><p>Reader 读取文件 log 中的序列化信息并打印到屏幕上。</p><p><strong>这个例子本身并无意义，但只要您稍加修改就可以将它变成更加有用的程序。比如将磁盘替换为网络 socket，那么就可以实现基于网络的数据交换任务。而存储和交换正是 Protobuf 最有效的应用领域。</strong></p><h3 id="和其他类似技术的比较"><a href="#和其他类似技术的比较" class="headerlink" title="和其他类似技术的比较"></a>和其他类似技术的比较</h3><p><strong>看完这个简单的例子之后，希望您已经能理解 Protobuf 能做什么了，那么您可能会说，世上还有很多其他的类似技术啊，比如 XML，JSON，Thrift 等等。和他们相比，Protobuf 有什么不同呢？</strong></p><p>简单说来 Protobuf 的主要优点就是：简单，快。<br>这有测试为证，项目 thrift-protobuf-compare 比较了这些类似的技术，图 1 显示了该项目的一项测试结果，Total Time.</p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-e42d037868db93e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/2000" alt="图1 性能测试结果"><br></div><p>Total Time 指一个对象操作的整个时间，包括创建对象，将对象序列化为内存中的字节序列，然后再反序列化的整个过程。从测试结果可以看到 Protobuf 的成绩很好，感兴趣的读者可以自行到网站 [<a href="https://github.com/eishay/jvm-serializers/wiki)上了解更详细的测试结果。" target="_blank" rel="noopener">https://github.com/eishay/jvm-serializers/wiki)上了解更详细的测试结果。</a></p><h4 id="Protobuf-的优点"><a href="#Protobuf-的优点" class="headerlink" title="Protobuf 的优点"></a>Protobuf 的优点</h4><ul><li><p>Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p></li><li><p>它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。</p></li><li><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p></li><li><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p></li></ul><h4 id="Protobuf-的不足"><a href="#Protobuf-的不足" class="headerlink" title="Protobuf 的不足"></a>Protobuf 的不足</h4><ul><li><p>Protbuf 与 XML 相比也有不足之处。它功能简单，无法用来表示复杂的概念。</p></li><li><p>XML 已经成为多种行业标准的编写工具，Protobuf 只是 Google 公司内部使用的工具，在通用性上还差很多。</p></li><li><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。</p></li></ul><h3 id="高级应用话题"><a href="#高级应用话题" class="headerlink" title="高级应用话题"></a>高级应用话题</h3><h4 id="更复杂的-Message"><a href="#更复杂的-Message" class="headerlink" title="更复杂的 Message"></a>更复杂的 Message</h4><p>到这里为止，我们只给出了一个简单的没有任何用处的例子。在实际应用中，人们往往需要定义更加复杂的 Message。我们用“复杂”这个词，不仅仅是指从个数上说有更多的 fields 或者更多类型的 fields，而是指更加复杂的数据结构：</p><ul><li><p><strong>嵌套 Message</strong></p><p>代码清单 4 给出一个嵌套 Message 的例子。</p></li></ul><p><em>清单 4. 嵌套 Message 的例子</em><br></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line"> required string name = 1;</span><br><span class="line"> required int32 id = 2;        // Unique ID number for this person.</span><br><span class="line"> optional string email = 3;</span><br><span class="line"></span><br><span class="line"> enum PhoneType &#123;</span><br><span class="line">   MOBILE = 0;</span><br><span class="line">   HOME = 1;</span><br><span class="line">   WORK = 2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> message PhoneNumber &#123;</span><br><span class="line">   required string number = 1;</span><br><span class="line">   optional PhoneType type = 2 [default = HOME];</span><br><span class="line"> &#125;</span><br><span class="line"> repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在 Message Person 中，定义了嵌套消息 PhoneNumber，并用来定义 Person 消息中的 phone 域。这使得人们可以定义更加复杂的数据结构。</p><ul><li><p><strong>Import Message</strong></p><p>在一个 .proto 文件中，还可以用 Import 关键字引入在其他 .proto 文件中定义的消息，这可以称做 Import Message，或者 Dependency Message。例子如下所示：<br><strong>清单 5. Import Message</strong></p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import common.header;</span><br><span class="line"></span><br><span class="line">message youMsg&#123;</span><br><span class="line"> required common.info_header header = 1;</span><br><span class="line"> required string youPrivateData = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 ,common.info_header定义在common.header包内。</p><blockquote><p>Import Message 的用处主要在于提供了方便的代码管理机制，类似 C 语言中的头文件。您可以将一些公用的 Message 定义在一个 package 中，然后在别的 .proto 文件中引入该 package，进而使用其中的消息定义。<br>Google Protocol Buffer 可以很好地支持嵌套 Message 和引入 Message，从而让定义复杂的数据结构的工作变得非常轻松愉快。</p></blockquote><h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>一般情况下，使用 Protobuf 的人们都会先写好 .proto 文件，再用 Protobuf 编译器生成目标语言所需要的源代码文件。将这些生成的代码和应用程序一起编译。</p><p>可是在某且情况下，人们无法预先知道 .proto 文件，他们需要动态处理一些未知的 .proto 文件。比如一个通用的消息转发中间件，它不可能预知需要处理怎样的消息。这需要动态编译 .proto 文件，并使用其中的 Message。</p><p><strong>Protobuf 提供了 google::protobuf::compiler 包来完成动态编译的功能。主要的类叫做 importer，定义在 importer.h 中。使用 Importer 非常简单，下图展示了与 Import 和其它几个重要的类的关系。</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-9166113b95e5d7a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/2000" alt="图 2. Importer 类"><br></div><p>首先构造一个 importer 对象。构造函数需要两个入口参数，一个是 source Tree 对象，该对象指定了存放 .proto 文件的源目录。第二个参数是一个 error collector 对象，该对象有一个 AddError 方法，用来处理解析 .proto 文件时遇到的语法错误。<br>之后，需要动态编译一个 .proto 文件时，只需调用 importer 对象的 import 方法。非常简单。</p><p>那么我们如何使用动态编译后的 Message 呢？我们需要首先了解几个其他的类。<br>Package google::protobuf::compiler 中提供了以下几个类，用来表示一个 .proto 文件中定义的 message，以及 Message 中的 field，如图3所示。</p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-57028764b0d9dc88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 3. 各个 Compiler 类之间的关系"><br></div><p>类 FileDescriptor 表示一个编译后的 .proto 文件；类 Descriptor 对应该文件中的一个 Message；类 FieldDescriptor 描述一个 Message 中的一个具体 Field。</p><p>比如编译完 lm.helloworld.proto 之后，可以通过如下代码得到 lm.helloworld.id 的定义：</p><p><strong>清单 7. 得到 lm.helloworld.id 的定义的代码</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protobuf::Descriptor *desc =</span><br><span class="line">   importer_.pool()-&gt;FindMessageTypeByName(“lm.helloworld”);</span><br><span class="line"><span class="keyword">const</span> protobuf::FieldDescriptor* field =</span><br><span class="line">   desc-&gt;pool()-&gt;FindFileByName (“id”);</span><br></pre></td></tr></table></figure><p></p><p>通过 Descriptor，FieldDescriptor 的各种方法和属性，应用程序可以获得各种关于 Message 定义的信息。比如通过 field-&gt;name() 得到 field 的名字。这样，您就可以使用一个动态定义的消息了。</p><h4 id="编写新的-proto-编译器"><a href="#编写新的-proto-编译器" class="headerlink" title="编写新的 proto 编译器"></a>编写新的 proto 编译器</h4><p>随 Google Protocol Buffer 源代码一起发布的编译器 protoc 支持 3 种编程语言：C++，java 和 Python。但使用 Google Protocol Buffer 的 Compiler 包，您可以开发出支持其他语言的新的编译器。</p><p>类 CommandLineInterface 封装了 protoc 编译器的前端，包括命令行参数的解析，proto 文件的编译等功能。您所需要做的是实现类 CodeGenerator 的派生类，实现诸如代码生成等后端工作：</p><p>程序的大体框架如图所示：</p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-440e574a983f7da8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 4. XML 编译器框图"><br></div><p>在 main() 函数内，生成 CommandLineInterface 的对象 cli，调用其 RegisterGenerator() 方法将新语言的后端代码生成器 yourG 对象注册给 cli 对象。然后调用 cli 的 Run() 方法即可。</p><p>这样生成的编译器和 protoc 的使用方法相同，接受同样的命令行参数，cli 将对用户输入的 .proto 进行词法语法等分析工作，最终生成一个语法树。该树的结构如图所示。</p><p></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/2639937-00e1d92873b596e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/2000" alt="图 5. 语法树"><br></div><br>其根节点为一个 FileDescriptor 对象（请参考“动态编译”一节），并作为输入参数被传入 yourG 的 Generator() 方法。在这个方法内，您可以遍历语法树，然后生成对应的您所需要的代码。简单说来，要想实现一个新的 compiler，您只需要写一个 main 函数，和一个实现了方法 Generator() 的派生类即可。<p></p></div><div class="reward"><div class="reward-wrap">赏<div class="reward-box"><span class="reward-type"><img class="alipay" src="/img/alipay.jpeg"><b>支付宝打赏</b></span> <span class="reward-type"><img class="wechat" src="/img/wepay.jpeg"><b>微信打赏</b></span></div></div><p class="reward-tip">赞赏是不耍流氓的鼓励</p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Bobo Huang</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/2018/10/15/RDMA-Driven-Paxos-Consistent-Algorithm/" class="pre-post btn btn-default" title="RDMA-Driven Paxos Consistent Algorithm"><i class="fa fa-angle-left fa-fw"></i> <span class="hidden-lg">上一篇</span> <span class="hidden-xs">RDMA-Driven Paxos Consistent Algorithm</span></a> <a href="/2018/06/08/C语言中snprintf-函数/" class="next-post btn btn-default" title="C语言中snprintf()函数"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">C语言中snprintf()函数</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><div id="vcomments" class="valine"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/assets/valine.min.js"></script><script>new Valine({av:AV,el:"#vcomments",appId:"xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz",appKey:"erIpQac4azoCmgfBB7Dl9maa",placeholder:"说点什么吧",notify:!1,verify:!1,avatar:"mm",meta:"nick,mail".split(","),pageSize:"10",path:window.location.pathname,lang:"".toLowerCase()})</script></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">Table of Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Google-Protocol-Buffer-Demo"><span class="toc-number">2.</span> <span class="toc-text">Google Protocol Buffer Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装Google-Protocol-Buffer"><span class="toc-number">2.0.1.</span> <span class="toc-text">安装Google Protocol Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo描述"><span class="toc-number">2.0.2.</span> <span class="toc-text">Demo描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建编写-proto-文件"><span class="toc-number">2.0.3.</span> <span class="toc-text">创建编写.proto 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译-proto-文件"><span class="toc-number">2.0.4.</span> <span class="toc-text">编译 .proto 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写-writer-和-Reader"><span class="toc-number">2.0.5.</span> <span class="toc-text">编写 writer 和 Reader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行结果"><span class="toc-number">2.0.6.</span> <span class="toc-text">运行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和其他类似技术的比较"><span class="toc-number">2.1.</span> <span class="toc-text">和其他类似技术的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf-的优点"><span class="toc-number">2.1.1.</span> <span class="toc-text">Protobuf 的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf-的不足"><span class="toc-number">2.1.2.</span> <span class="toc-text">Protobuf 的不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级应用话题"><span class="toc-number">2.2.</span> <span class="toc-text">高级应用话题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#更复杂的-Message"><span class="toc-number">2.2.1.</span> <span class="toc-text">更复杂的 Message</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态编译"><span class="toc-number">2.2.2.</span> <span class="toc-text">动态编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写新的-proto-编译器"><span class="toc-number">2.2.3.</span> <span class="toc-text">编写新的 proto 编译器</span></a></li></ol></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi"></div></div><div class="col-sm-12"><span>Copyright &copy; 2019</span> | <span>Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a></span> | <span>Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a></span></div></div></div></div><script src="/js/app.js?rev=f25479a641009e7423ae98c6f819957f"></script></body></html>